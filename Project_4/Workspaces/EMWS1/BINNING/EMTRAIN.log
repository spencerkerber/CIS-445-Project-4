MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 12, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13:26:25" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                November 12, 2015
Time:                13:26:25
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O3QEJ51X "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O3QEJ51X new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 12, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13:26:25" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                sakerb01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70080760";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_7PRO";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M1P120413";
MPRINT(EM_DIAGRAM):   put "EM Version:          13.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 12, 2015" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13:26:25" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                sakerb01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
28088      proc freq data=EMWS1.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.BINNING_VariableSet noprint;
28089      table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
28090      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 6 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.07 seconds
      cpu time            0.07 seconds
      

28091      proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
28092      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
28093      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
28094      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
28095      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
28096      run;

NOTE: There were 6 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

28097      title10;
MPRINT(EM_DIAGRAM):   title10;
28098      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Project_4';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'P4';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28451      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
28452      * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
28453      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
28454      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

28455      %let EMEXCEPTIONSTRING=;
28456      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
28457      * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
28458      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
28459      %let EM_ACTION = TRAIN;
28460      %let syscc = 0;
28461      %macro main;
28462      
28463        filename temp catalog 'sashelp.emmdfy.binning_macros.source';
28464        %include temp;
28465        filename temp;
28466      
28467        %setProperties;
28468      
28469        %if %upcase(&EM_ACTION) = CREATE %then %do;
28470          filename temp catalog 'sashelp.emmdfy.binning_create.source';
28471          %include temp;
28472          filename temp;
28473      
28474          %create;
28475        %end;
28476      
28477         %else
28478         %if %upcase(&EM_ACTION) = TRAIN %then %do;
28479      
28480             filename temp catalog 'sashelp.emmdfy.binning_train.source';
28481             %include temp;
28482             filename temp;
28483             %train;
28484         %end;
28485      
28486        %else
28487        %if %upcase(&EM_ACTION) = SCORE %then %do;
28488          filename temp catalog 'sashelp.emmdfy.binning_score.source';
28489          %include temp;
28490          filename temp;
28491      
28492          %score;
28493      
28494        %end;
28495      
28496        %else
28497        %if %upcase(&EM_ACTION) = REPORT %then %do;
28498      
28499             filename temp catalog 'sashelp.emmdfy.binning_report.source';
28500             %include temp;
28501             filename temp;
28502      
28503             %report;
28504         %end;
28505      
28506         %doendm:
28507      %mend main;
28508      
28509      %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
28510     +
28511     +%macro SetProperties;
28512     +
28513     +     /* IGN options */
28514     +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
28515     +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
28516     +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
28517     +
28518     +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
28519     +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
28520     +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
28521     +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
28522     +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
28523     +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
28524     +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
28525     +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
28526     +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
28527     +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
28528     +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
28529     +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
28530     +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
28531     +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
28532     +
28533     +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
28534     +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
28535     +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
28536     +
28537     +
28538     +%mend SetProperties;
28539     +%macro appendfiles(fileref1, fileref2);
28540     +     data _null_;
28541     +       length c $256;
28542     +       fid1=fopen("&fileref1",'A');
28543     +       fid2=fopen("&fileref2",'I');
28544     +       cval = finfo(fid2,'lrecl');
28545     +       put cval= fid1= fid2=;
28546     +       if (fid2 > 0) then
28547     +         do while(fread(fid2)=0);
28548     +           rc = fget(fid2,c,256);
28549     +           _msg_=sysmsg();
28550     +           /* put rc= c= _msg_=; */
28551     +           rc = fput(fid1,strip(c));
28552     +           rc = fwrite(fid1);
28553     +         end;
28554     +         _msg_=sysmsg();
28555     +         put _msg_=;
28556     +       rc = fclose(fid1);
28557     +       rc = fclose(fid2);
28558     +     run;
28559     +%mend appendfiles;
28560     +
28561     +%macro buildOptScoreCode;
28562     +
28563     +    %em_register(key=BINCODE, type=FOLDER);
28564     +
28565     +    filename x catalog 'sashelp.emutil.em_deldir.source';
28566     +    %inc x;
28567     +    filename x;
28568     +    %delDir(folder=%nrbquote(&em_user_bincode));
28569     +
28570     +    data _null_; length rc $200;
28571     +       rc = dcreate('BINCODE', "&EM_NODEDIR");
28572     +    run;
28573     +
28574     +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
28575     +
28576     +    %let dsid = %sysfunc(open(class_nosv));
28577     +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
28578     +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
28579     +
28580     +    %let oldname=;
28581     +    %do %while(^%sysfunc(fetch(&dsid)));
28582     +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
28583     +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
28584     +
28585     +        %if &name ne &oldname %then %do;
28586     +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
28587     +             data _null_;
28588     +                length string $200 flag endflag 8;
28589     +                retain string flag endflag;
28590     +                set class_nosv end=eof;
28591     +                where DISPLAY_VAR ="&name";
28592     +                by _variable_ _group_;
28593     +                file _F1;
28594     +                index = kindex(_variable_, "BIN_");
28595     +                if index gt 0 then do;
28596     +                   if first._variable_ then do;
28597     +                      put ' ';
28598     +                      put "&EM_CODEBAR;";
28599     +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
28600     +                      put string;
28601     +                      put "&EM_CODEBAR;";
28602     +
28603     +                      if origLabel ne "" then do;
28604     +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
28605     +                            put string;
28606     +                            string = tranwrd(origLabel,"'","''");
28607     +                            string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
28608     +                            put string;
28609     +                      end;
28610     +                      else do;
28611     +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
28612     +                             put string;
28613     +                      end;
28614     +
28615     +                      put ' ';
28616     +
28617     +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28618     +                      put string;
28619     +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28620     +                      put string;
28621     +                      put "end;";
28622     +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28623     +                      put string;
28624     +                   end;
28625     +                   if first._group_ then do;
28626     +                      flag = 0;
28627     +                      endflag = 1;
28628     +                      if ^first._variable_ then do;
28629     +                         put "else";
28630     +                      end;
28631     +                      if LB ne . then do;
28632     +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
28633     +                      end;
28634     +                      else do;
28635     +                         flag = 1;
28636     +                         string = "if";
28637     +                      end;
28638     +                   end;
28639     +                   if last._Group_ then do;
28640     +                      if UB ne . then do;
28641     +                        if flag ne 1 then do;
28642     +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
28643     +                        end;
28644     +                        else do;
28645     +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
28646     +                        end;
28647     +                      end;
28648     +                      else do;
28649     +                         if flag=1 then do;
28650     +                            string = strip(DISPLAY_VAR) ;
28651     +                            string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
28652     +                            endflag=0;
28653     +                            string="";
28654     +                         end;
28655     +                         else do;
28656     +                            string = strip(string)!!" then do;";
28657     +                         end;
28658     +                      end;
28659     +                      put string;
28660     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
28661     +                      put string;
28662     +                      if endflag eq 1 then do;
28663     +                        put "end;";
28664     +                      end;
28665     +                   end;
28666     +                   if last._variable_ then do;
28667     +                     string = "end;";
28668     +                     put string;
28669     +                   end;
28670     +
28671     +                end;
28672     +                else do;
28673     +                   _split_value_ = tranwrd(_split_value_,"'","''");
28674     +                   if first._group_ then do;
28675     +                      flag=0;
28676     +                      if ^first._variable_ then
28677     +                         put 'else';
28678     +                      else do;
28679     +                         put ' ';
28680     +                         put "&EM_CODEBAR;";
28681     +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
28682     +                         put string;
28683     +                         put "&EM_CODEBAR;";
28684     +
28685     +                         if origLabel ne "" then do;
28686     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
28687     +                               put string;
28688     +                               string = tranwrd(origLabel,"'","''");
28689     +                               string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
28690     +                               put string;
28691     +                         end;
28692     +                         else do;
28693     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
28694     +                               put string;
28695     +                         end;
28696     +
28697     +                         put ' ';
28698     +
28699     +                         if format ne '' then do;
28700     +                            if first._variable_ then do;
28701     +                               string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
28702     +                               put string;
28703     +                               string = '%dmnormip(_UFormat);';
28704     +                               put string;
28705     +
28706     +                               string ="if MISSING(_UFORMAT) then do;";
28707     +                               put string;
28708     +                               string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28709     +                               put string;
28710     +                               put "end;";
28711     +
28712     +                               string="else if NOT MISSING(_UFORMAT) then do;";
28713     +                               put string;
28714     +
28715     +                            end;
28716     +                         end;
28717     +                         else do;
28718     +                            if type = 'N' then do;
28719     +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28720     +                              put string;
28721     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28722     +                              put string;
28723     +                              put "end;";
28724     +
28725     +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28726     +                              put string;
28727     +                            end;
28728     +                            else if type='C' then do;
28729     +                              string = "_UFormat = "||strip(DISPLAY_VAR)||";";
28730     +                              put string;
28731     +                              string = '%dmnormip(_UFormat);';
28732     +                              put string;
28733     +
28734     +                              string ="if MISSING(_UFORMAT) then do;";
28735     +                              put string;
28736     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28737     +                              put string;
28738     +                              put "end;";
28739     +
28740     +                              string="else if NOT MISSING(_UFORMAT) then do;";
28741     +                              put string;
28742     +                              string = '%dmnormip(_UFormat);';
28743     +                              put string;
28744     +                           end;
28745     +                         end;
28746     +                      end;
28747     +                      if format ne '' OR type='C' then do;
28748     +                        string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
28749     +                      end;
28750     +                      else do;
28751     +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
28752     +                      end;
28753     +                   end;
28754     +                   else do;
28755     +                      if flag ne 1 then do;
28756     +                       if format ne '' OR type='C' then do;
28757     +                         tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
28758     +                       end;
28759     +                       else do;
28760     +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
28761     +                       end;
28762     +                         length = length(tempstring);
28763     +
28764     +                         if length < 195 then do;
28765     +                            string = tempstring;
28766     +                         end;
28767     +                         else do;
28768     +
28769     +                            string = strip(string);
28770     +                            put string;
28771     +                            string = ") then do;";
28772     +                            put string;
28773     +
28774     +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
28775     +                            put string;
28776     +                            put "end;";
28777     +
28778     +                            put 'else';
28779     +                            if format ne '' OR type='C' then do;
28780     +                              string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
28781     +                            end;
28782     +                            else do;
28783     +                              string = "if "!!strip(DISPLAY_VAR)!!" eq ("!!strip(_split_value_);
28784     +                            end;
28785     +                         end;
28786     +                      end;
28787     +                   end;
28788     +
28789     +                   if last._group_ then do;
28790     +                      string = strip(string);
28791     +                      put string;
28792     +
28793     +                      string = ") then do;";
28794     +                      put string;
28795     +
28796     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
28797     +                      put string;
28798     +                      put "end;";
28799     +                   end;
28800     +
28801     +                   if last._variable_ then do;
28802     +                     put "else do;";
28803     +
28804     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28805     +                     put string;
28806     +
28807     +                     put "end;";
28808     +                     put "end;";
28809     +                   end;
28810     +                end;
28811     +             run;
28812     +
28813     +             %let oldname = &name;
28814     +        %end;
28815     +    %end;
28816     +    %let dsid = %sysfunc(close(&dsid));
28817     +
28818     +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
28819     +    data _null_;
28820     +       file _F1;
28821     +       put "length _UFormat $200;";
28822     +       put "drop _UFormat;";
28823     +       put "_UFormat='';";
28824     +    run;
28825     +    filename _F1;
28826     +
28827     +   %em_register(key=EMSCOREVAR, type=DATA);
28828     +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
28829     +   proc datasets lib=&em_lib nolist;
28830     +      delete &scorevarDs;
28831     +   run;
28832     +   quit;
28833     +
28834     +   %let filrf=mydir;
28835     +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
28836     +   %let did=%sysfunc(dopen(&filrf));
28837     +
28838     +   %if &did %then %do;  %PUT  did= &did;
28839     +       %let memcount=%sysfunc(dnum(&did));
28840     +       %if &memcount > 0 %then %do;
28841     +           data &em_user_emscorevar;
28842     +              length Name $32 formula $70 file $200;
28843     +              keep NAME Formula file;
28844     +              formula  = '';
28845     +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
28846     +               name=''; file="BINCODE&em_dsep._ALL_.sas";
28847     +               output;
28848     +           %end;
28849     +           %do i=1 %to &memcount;
28850     +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
28851     +               %let newvar = %scan(&name, 1, .);
28852     +               %if "&newvar" ne "_ALL_" %then %do;
28853     +                   name = "&newvar"; file="BINCODE&em_dsep&name";
28854     +                   output;
28855     +               %end;
28856     +           %end;
28857     +
28858     +           run;
28859     +       %end;
28860     +       %let did = %sysfunc(dclose(&did));
28861     +  %end;
28862     +
28863     +   %doendu:
28864     +%mend buildOptScoreCode;
28865     +
28866     +
28867     +%macro buildScoreCode(flowCode, publishCode);
28868     +
28869     +
28870     +  filename x "&flowCode";
28871     +
28872     +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
28873     +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
28874     +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
28875     +
28876     +  data temp;
28877     +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
28878     +    by display_var _Split_value_;
28879     +     if upcase(_Split_value_) ne 'MISSING';
28880     +   run;
28881     +
28882     +   data temp_missing;
28883     +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP)) &EM_USER_BINMAPPINGS(rename=(
28884     +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
28885     +     by display_var _Split_value_;
28886     +     if upcase(_Split_value_) eq 'MISSING';
28887     +     keep _variable_ display_var missgrp;
28888     +   run;
28889     +
28890     +   proc sort data=temp_missing; by display_var missgrp; run;
28891     +
28892     +   data temp_missing;
28893     +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
28894     +     by display_var missgrp;
28895     +     if ^_a then delete;
28896     +     keep _variable_ display_var missgrp ;
28897     +   run;
28898     +
28899     +   data temp;
28900     +     merge temp temp_missing;
28901     +     by display_var;
28902     +     if display_Var eq '' then delete;
28903     +    run;
28904     +
28905     +    /* pull in wtev values */
28906     +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
28907     +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
28908     +    proc sort data=temp;  by display_var _group_; run;
28909     +
28910     +   data temp;
28911     +      merge temp tempcoarse(keep=display_var _group_  role) ;
28912     +      by display_var _group_;
28913     +    run;
28914     +
28915     +    data temp;
28916     +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
28917     +      by display_var;
28918     +
28919     +      if _group_ = . then delete;
28920     +      if _variable_ = '' then delete;
28921     +    run;
28922     +
28923     +    proc sort data=temp out=class;
28924     +       by _variable_ _group_ LB;
28925     +    run;
28926     +
28927     +    data _null_;
28928     +      file X;
28929     +
28930     +      put "length _UFormat $200;";
28931     +      put "drop _UFormat;";
28932     +      put "_UFormat='';";
28933     +    run;
28934     +
28935     +    data class_nosv;
28936     +      set class;
28937     +      if upcase(role)="INPUT";
28938     +    run;
28939     +
28940     +    data _null_;
28941     +       file X MOD;
28942     +       length string $200 flag endflag 8;
28943     +       retain string flag endflag;
28944     +       set class_nosv end=eof;
28945     +       by _variable_ _group_;
28946     +
28947     +       index = kindex(_variable_, "BIN_");
28948     +       if index gt 0 then do;
28949     +
28950     +         if first._variable_ then do;
28951     +            put ' ';
28952     +            put "&EM_CODEBAR;";
28953     +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
28954     +            put string;
28955     +            put "&EM_CODEBAR;";
28956     +
28957     +
28958     +            if origLabel ne "" then do;
28959     +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
28960     +              put string;
28961     +              string = tranwrd(origLabel,"'","''");
28962     +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
28963     +              put string;
28964     +            end;
28965     +            else do;
28966     +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
28967     +             put string;
28968     +            end;
28969     +
28970     +            put ' ';
28971     +
28972     +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28973     +            put string;
28974     +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
28975     +            put string;
28976     +            put "end;";
28977     +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
28978     +            put string;
28979     +          end;
28980     +           if first._group_ then do;
28981     +              flag = 0;
28982     +              endflag = 1;
28983     +              if ^first._variable_ then do;
28984     +                put "else";
28985     +              end;
28986     +              if LB ne . then do;
28987     +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
28988     +              end;
28989     +              else do;
28990     +                 flag = 1;
28991     +                 string = "if";
28992     +              end;
28993     +
28994     +           end;
28995     +           if last._Group_ then do;
28996     +              if UB ne . then do;
28997     +                if flag ne 1 then do;
28998     +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
28999     +                end;
29000     +                else do;
29001     +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
29002     +                end;
29003     +              end;
29004     +              else do;
29005     +                 if flag=1 then do;
29006     +                   string = strip(DISPLAY_VAR) ;
29007     +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
29008     +                   endflag = 0;
29009     +                   string="";
29010     +                 end;
29011     +                 else do;
29012     +                   string = strip(string)!!" then do;";
29013     +                 end;
29014     +              end;
29015     +              put string;
29016     +
29017     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
29018     +              put string;
29019     +              if endflag eq 1 then do;
29020     +                put "end;";
29021     +              end;
29022     +           end;
29023     +           if last._variable_ then do;
29024     +             string = "end;";
29025     +             put string;
29026     +           end;
29027     +       end;
29028     +       else do;
29029     +           _split_value_ = tranwrd(_split_value_,"'","''");
29030     +           if first._group_ then do;
29031     +              flag=0;
29032     +              if ^first._variable_ then
29033     +                 put 'else';
29034     +              else do;
29035     +                 put ' ';
29036     +                 put "&EM_CODEBAR;";
29037     +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
29038     +                 put string;
29039     +                 put "&EM_CODEBAR;";
29040     +
29041     +                 if origLabel ne "" then do;
29042     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
29043     +                   put string;
29044     +                   string = tranwrd(origLabel,"'","''");
29045     +                   string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
29046     +                   put string;
29047     +                 end;
29048     +                 else do;
29049     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
29050     +                   put string;
29051     +                 end;
29052     +
29053     +                 put ' ';
29054     +
29055     +                if format ne '' then do;
29056     +                  if first._variable_ then do;
29057     +                    string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
29058     +                    put string;
29059     +                    string = '%dmnormip(_UFormat);';
29060     +                    put string;
29061     +
29062     +                     string ="if MISSING(_UFORMAT) then do;";
29063     +                     put string;
29064     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
29065     +                     put string;
29066     +                     put "end;";
29067     +
29068     +                     string="else if NOT MISSING(_UFORMAT) then do;";
29069     +                     put string;
29070     +
29071     +                  end;
29072     +                end;
29073     +                else do;
29074     +                     if type = 'N' then do;
29075     +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
29076     +                       put string;
29077     +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
29078     +                       put string;
29079     +                       put "end;";
29080     +
29081     +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
29082     +                       put string;
29083     +
29084     +                     end;
29085     +                     else if type='C' then do;
29086     +                        string = "_UFormat = "||strip(DISPLAY_VAR)||";";
29087     +                        put string;
29088     +                        string = '%dmnormip(_UFormat);';
29089     +                        put string;
29090     +
29091     +                        string ="if MISSING(_UFORMAT) then do;";
29092     +                        put string;
29093     +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
29094     +                        put string;
29095     +                        put "end;";
29096     +
29097     +                        string="else if NOT MISSING(_UFORMAT) then do;";
29098     +                        put string;
29099     +                        string = '%dmnormip(_UFormat);';
29100     +                        put string;
29101     +                    end;
29102     +                end;
29103     +              end;
29104     +              if format ne '' OR type='C' then do;
29105     +                string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
29106     +              end;
29107     +              else do;
29108     +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
29109     +              end;
29110     +           end;
29111     +           else do;
29112     +              if flag ne 1 then do;
29113     +                if format ne '' OR type='C' then do;
29114     +                  tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
29115     +                end;
29116     +                else do;
29117     +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
29118     +                end;
29119     +                length = klength(tempstring);
29120     +
29121     +                if length < 195 then do;
29122     +                   string = tempstring;
29123     +                end;
29124     +                else do;
29125     +
29126     +                   string = strip(string);
29127     +                   put string;
29128     +                   string = ") then do;";
29129     +                   put string;
29130     +
29131     +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
29132     +                   put string;
29133     +                   put "end;";
29134     +
29135     +                 /*  string = strip(string)||",'...';"; */
29136     +
29137     +                   put 'else';
29138     +                   if format ne '' OR type='C' then do;
29139     +                     string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
29140     +                   end;
29141     +                   else do;
29142     +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
29143     +                   end;
29144     +
29145     +
29146     +                end;
29147     +              end;
29148     +           end;
29149     +
29150     +           if last._group_ then do;
29151     +              string = strip(string);
29152     +              put string;
29153     +              string = ") then do;";
29154     +              put string;
29155     +
29156     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
29157     +              put string;
29158     +              put "end;";
29159     +           end;
29160     +
29161     +           if last._variable_ then do;
29162     +             put "else do;";
29163     +
29164     +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
29165     +             put string;
29166     +
29167     +             put "end;";
29168     +             put "end;";
29169     +           end;
29170     +         *end;
29171     +       end;
29172     +    run;
29173     +
29174     +    /* generate PublishCode the same as flowscorecode */
29175     +    filename Y "&publishCode";
29176     +
29177     +    /* if publishCode already exists, wipe it out first */
29178     +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
29179     +      %let rc = %sysfunc(fdelete(Y));
29180     +    %end;
29181     +
29182     +    %appendfiles(Y, X);
29183     +
29184     +    %if %EM_BINARY_TARGET= %then %do;
29185     +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
29186     +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet, where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")), nummacro=em_num_interval_Target);
29187     +      %end;
29188     +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
29189     +      %let ibn_inttarget_orig = &ibn_inttarget;
29190     +
29191     +      %if %symexist(IGNBinTarget)=0 %then %do;
29192     +         %global ignbintarget ignfreqvar;
29193     +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
29194     +         %include temp;
29195     +         filename temp;
29196     +         %getVarName(&EM_IMPORT_DATA, BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))), IGNBinTarget);
29197     +
29198     +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
29199     +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
29200     +         %end;
29201     +      %end;
29202     +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
29203     +         proc sql noprint;
29204     +            %if %EM_FREQ ne %then %do;
29205     +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
29206     +            %end;
29207     +            %else %do;
29208     +               select mean(&ibn_inttarget)
29209     +            %end;
29210     +            into :ignbincut trimmed from &EM_IMPORT_DATA;
29211     +         quit;
29212     +      %end;
29213     +
29214     +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
29215     +      %if &dsid %then %do;
29216     +         %let tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
29217     +         %let rc=%sysfunc(close(&dsid));
29218     +      %end;
29219     +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
29220     +
29221     +      data _null_;
29222     +         file x mod;
29223     +         put ' ';
29224     +
29225     +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
29226     +             put "&EM_CODEBAR;";
29227     +             %let note = Mean Cutoff Binary Transformation for Target;
29228     +             put "* &note;";
29229     +             put "&EM_CODEBAR;";
29230     +         %end;
29231     +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
29232     +             put "&EM_CODEBAR;";
29233     +             %let note = User-Specified Cutoff Binary Transformation for Target;
29234     +             put "* &note;";
29235     +             put "&EM_CODEBAR;";
29236     +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
29237     +         %end;
29238     +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
29239     +         put "else do;";
29240     +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
29241     +         put "   else &IGNBinTarget=0;";
29242     +         put "end;";
29243     +
29244     +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
29245     +      run;
29246     +
29247     +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
29248     +
29249     +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
29250     +
29251     +         data _null_;
29252     +            file deltaref;
29253     +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
29254     +            put "if name='&IGNBinTarget' then do;";
29255     +            put "   role='TARGET';";
29256     +            put "   level='BINARY';";
29257     +            put "end;";
29258     +         run;
29259     +
29260     +      %end;
29261     +      %else %do;
29262     +
29263     +         data _null_;
29264     +            file deltaref;
29265     +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
29266     +            put "if name='&IGNBinTarget' then do;";
29267     +            put "   role='REJECTED';";
29268     +            put "   level='BINARY';";
29269     +            put "end;";
29270     +         run;
29271     +      %end;
29272     +
29273     +      filename deltaref;
29274     +
29275     +   %end;
29276     +
29277     +    filename X;
29278     +    filename Y;
29279     +
29280     +    %buildOptScoreCode;
29281     +
29282     +    proc datasets library=work nolist;
29283     +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
29284     +    run;
29285     +    quit;
29286     +
29287     +%mend buildScoreCode;
29288     +
29289     +%macro buildMetaCode(DeltaCodeFile=);
29290     +
29291     +   /* set variable roles based on New Role column in the Results table */
29292     +   data _null_;
29293     +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
29294     +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
29295     +      %if &dsid %then %do;
29296     +        %let obs = %sysfunc(fetch(&dsid));
29297     +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
29298     +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
29299     +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
29300     +
29301     +        %do %while(&obs=0);
29302     +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
29303     +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
29304     +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
29305     +
29306     +          /* retrieve grp and woe names from varmappings dataset */
29307     +          %let choice = _VARIABLE_ = "&inputname";
29308     +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
29309     +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
29310     +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
29311     +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
29312     +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
29313     +
29314     +          put "if name = '&inputname' then role='REJECTED';";
29315     +          %if "&role" ne "DEFAULT" %then %do;
29316     +            put "if name = '&grpname' then role='&role';";
29317     +          %end;
29318     +          %else %do;
29319     +            put "if name = '&grpname' then role='&oldrole';";
29320     +          %end;
29321     +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
29322     +
29323     +          %let obs = %sysfunc(fetch(&dsid));
29324     +        %end;
29325     +      %end;
29326     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29327     +   run;
29328     +
29329     +   /* drop all vars in the splitvals dataset that aren't present in the varmappings dataset */
29330     +   data _null_;
29331     +      file &DeltaCodeFile MOD;
29332     +
29333     +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
29334     +      %if &sdsid %then %do;
29335     +        %let sobs = %sysfunc(fetch(&sdsid));
29336     +        %do %while(&sobs=0);
29337     +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
29338     +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
29339     +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
29340     +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
29341     +
29342     +          %let checkgrp = GRP_&checkname;
29343     +          %let lenname = %length(&checkgrp);
29344     +          %if %eval(&lenname-32) > 0 %then %do;
29345     +            %let checkgrp = %substr(&checkgrp, 1, 32);
29346     +          %end;
29347     +
29348     +          %let choice = _VARIABLE_ ="&checkname";
29349     +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
29350     +
29351     +          /* if var not found in varmappings, delete variables; */
29352     +          /* this could happen when freeze=Y and vars in the frozen dataset aren't in the incoming training data */
29353     +          %if &vdsid eq 0 %then %do;
29354     +            put 'if name="&displayvar" then delete;';
29355     +            %let dispgrp = GRP_&displayvar;
29356     +            put 'if name="&dispgrp" then delete;';
29357     +          %end;
29358     +
29359     +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
29360     +          %let sobs = %sysfunc(fetch(&sdsid));
29361     +        %end;
29362     +      %end;
29363     +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
29364     +   run;
29365     +
29366     +%mend buildMetaCode;
29367     +
29368     +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
29369     +
29370     +   proc sort data=&coarse out=sortedcoarse nodupkey;
29371     +     by display_var;
29372     +   run;
29373     +   proc sort data=&varmappings nodupkey;
29374     +     by _variable_;
29375     +   run;
29376     +   %if %sysfunc(exist(&resultstable, data)) %then %do;
29377     +     proc sort data=&resultstable; by display_var; run;
29378     +   %end;
29379     +
29380     +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
29381     +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
29382     +     %if %sysfunc(exist(&resultstable, data)) %then %do;
29383     +        &resultstable (keep = display_var _new_role_ )
29384     +     %end;
29385     +     ;
29386     +     by display_var;
29387     +     length _role_ _new_role_ $10;
29388     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
29389     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel , NOQUOTE))"
29390     +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel, NOQUOTE))"
29391     +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel, NOQUOTE))"
29392     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))"
29393     +           ;
29394     +
29395     +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
29396     +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
29397     +                _role_ = "Rejected";
29398     +             else _role_ = "Input";
29399     +           %end;
29400     +           %else %do;
29401     +             _role_ = "Input";
29402     +           %end;
29403     +           if _new_role_ eq "" then _new_role_="Default";
29404     +      if ^_a then do;
29405     +        _gini_ = 0;
29406     +        _role_ = 'Rejected';
29407     +        if _new_role_ eq "" then _new_role_="Default";
29408     +      end;
29409     +   run;
29410     +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL rename=(NAME=display_var LABEL=_label_));
29411     +     by NAME;
29412     +   run;
29413     +   data outlabel;
29414     +     set outlabel;
29415     +     if _label_ = '' then _label_ = _variable_;
29416     +   run;
29417     +   data &resultstable;
29418     +     merge &resultstable(in=_a_) outlabel;
29419     +     by display_Var;
29420     +     if _a_ then output;
29421     +   run;
29422     +   proc datasets library=work nolist;
29423     +     delete sortedcoarse outlabel;
29424     +   run;
29425     +   quit;
29426     +   proc sort data=&resultstable nodupkey;
29427     +      by DESCENDING
29428     +        _gini_ display_Var;
29429     +   run;
29430     +   data &resultstable;
29431     +     set &resultstable;
29432     +
29433     +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))"
29434     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))";
29435     +     giniOrder = _N_;
29436     +     _gini_ = round(_GINI_, .001);
29437     +     drop _variable_;
29438     +   run;
29439     +
29440     +   proc print data=&resultstable label;
29441     +   run;
29442     +
29443     +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
29444     +   data &coarse;
29445     +     set &coarse;
29446     +     length role $10;
29447     +     %let dsid = %sysfunc(open(&resultstable));
29448     +     %if &dsid %then %do;
29449     +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
29450     +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
29451     +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
29452     +
29453     +       %let obs = %sysfunc(fetch(&dsid));
29454     +       %do %while(&obs=0);
29455     +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
29456     +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
29457     +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
29458     +
29459     +                                                                                               if DISPLAY_VAR = "&displayVar" then do;
29460     +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))";
29461     +            giniOrder = &order;
29462     +            role = "&role";
29463     +          end;
29464     +
29465     +          %let obs = %sysfunc(fetch(&dsid));
29466     +       %end;
29467     +     %end;
29468     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29469     +   run;
29470     +
29471     +
29472     +%mend EM_GENERATE_RESULTSTABLE;
29473     +
29474     +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
29475     +
29476     +    /* instantiate the zchar macro to be used in adding bin definition */
29477     +    filename _temp catalog 'sashelp.emmacs.zchar.source';
29478     +    %inc _temp;
29479     +    filename _temp;
29480     +
29481     +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
29482     +      by _variable_ binFlag _group_ LB;
29483     +    run;
29484     +
29485     +    data tempExport;
29486     +      set sortedFine;
29487     +      by _variable_ binFlag _group_;
29488     +      length _split_value_ $200;
29489     +
29490     +      /* for all binned variables, need to modify the split value to original cutoff as well as change level to interval */
29491     +      if binFlag = 0 then do;
29492     +        index = kindex(_variable_, "BIN_");
29493     +        if index gt 0 then do;
29494     +          _LEVEL_ = "INTERVAL";
29495     +        end;
29496     +        _Split_value_ = _split_value_;
29497     +        output;
29498     +      end;
29499     +      else do;
29500     +         * if last._group_ then do;
29501     +          index = kindex(_variable_, "BIN_");
29502     +          if index gt 0 then do;
29503     +            _LEVEL_ = "INTERVAL";
29504     +          end;
29505     +          _Split_value_ = %zchar(UB);
29506     +          output;
29507     +         * end;
29508     +      end;
29509     +
29510     +      rename display_Var = _variable_;
29511     +      keep display_var _level_ _group_ _split_value_ binFlag;
29512     +    run;
29513     +
29514     +    %if &CREATEMETHOD eq OVERWRITE %then %do;
29515     +       data &EXPORTGROUPING;
29516     +         set tempexport;
29517     +       run;
29518     +    %end;
29519     +    %else %do;
29520     +       /* determine if EXPORTGROUPING already exists */
29521     +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
29522     +         data &EXPORTGROUPING;
29523     +            set &EXPORTGROUPING tempexport;
29524     +         run;
29525     +       %end;
29526     +       %else %do;
29527     +         data &EXPORTGROUPING;
29528     +            set tempexport;
29529     +         run;
29530     +       %end;
29531     +    %end;
29532     +
29533     +    proc datasets lib=work nolist;
29534     +      delete sortedFine tempexport;
29535     +    run;
29536     +    quit;
29537     +
29538     +%mend EM_GENERATE_EXPORTGROUP;
29539     +
29540     +
29541     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
29544     +%macro train;
29546     +   /* include training macros */
29547     +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
29548     +   %include trtemp;
29549     +   filename trtemp;
29551     +   /* trick IGN into thinking it is a model node to build decmeta; further down, set %EM_MODEL ASSESS=N
29552     +   %let EM_TOOLTYPE = MODEL; */
29554     +   %if &EM_IMPORT_DATA eq %then %do;
29555     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
29556     +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note , NOQUOTE));
29557     +       %put &em_codebar;
29558     +       %put &errmsg;
29559     +       %put &em_codebar;
29560     +       %goto doendm;
29561     +   %end;
29563     +   %if  &EM_NUM_TARGET ne 1 %then %do;
29564     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
29565     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
29566     +        %put &em_codebar;
29567     +        %put &errmsg;
29568     +        %put &em_codebar;
29569     +        %goto doendm;
29570     +   %end;
29572     +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
29573     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
29574     +        %put &em_codebar;
29575     +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
29576     +        %put &errormsg;
29577     +        %put &em_codebar;
29578     +        %goto doendm;
29579     +   %end;
29581     +   /* Initialize property macro variables */
29582     +   %SetProperties;
29583     +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
29585     +   /* check actual num of target levels */
29586     +   %let target_level = %EM_TARGET_LEVEL;
29587     +   %let target_var = %EM_TARGET;
29588     +   %if (&target_Level eq BINARY) %then %do;
29589     +      /* retrieve target information */
29590     +      /* does decmeta exist?  If not, retrieve target information elsewhere */
29591     +      %global target_event;
29592     +      %let target_event=;
29593     +      %if "&EM_DEC_DECMETA" eq "" %then %do;
29594     +        /* retrieve type and format from variableset */
29595     +        %let eventorder = DESC;
29596     +        data temp;
29597     +          set &EM_DATA_VARIABLESET;
29598     +          where NAME ="%EM_BINARY_TARGET";
29599     +        run;
29600     +        %let dsid = %sysfunc(open(work.temp));
29601     +        %if &dsid %then %do;
29602     +          %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
29603     +          %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
29604     +          %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
29605     +          %let obs = %sysfunc(fetchobs(&dsid, 1));
29606     +          %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
29607     +          %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
29608     +          %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
29609     +          %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
29610     +             %else
29611     +          %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
29612     +             %else
29613     +          %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
29614     +             %else
29615     +          %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
29616     +        %end;
29617     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29619     +        /* retrieve target_event and Target_nonEvent values */
29620     +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET))) classout=EVENTOUT;
29621     +          target %EM_BINARY_TARGET;
29622     +          class  %EM_BINARY_TARGET(&eventorder);
29623     +        run;
29625     +        data _null_;
29626     +          dsid = open("EVENTOUT");
29627     +          if dsid>0 then do;
29628     +          levelnum = VARNUM(dsid, "LEVEL");
29629     +          if levelnum then do;
29630     +            if ^fetch(dsid) then
29631     +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
29633     +            if ^fetch(dsid) then
29634     +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
29635     +          end;
29636     +          dsid=close(dsid);
29637     +          end;
29638     +        run;
29639     +        proc datasets library=work nolist;
29640     +           delete eventout;
29641     +        run;
29642     +        quit;
29643     +      %end;
29644     +      %else %do;
29645     +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
29647     +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
29648     +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
29649     +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
29651     +         %do %while(^ %sysfunc(fetch(&dsid)));
29652     +            %let Target_Event = %sysfunc(getvarc(&dsid, &vn_event));
29653     +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
29654     +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
29655     +         %end;
29656     +         %let dsid = %sysfunc(close(&dsid));
29658     +         %let dsid=%sysfunc(open(&EM_DEC_DECDATA));
29659     +           %let obs = %sysfunc(fetchobs(&dsid, 2));
29660     +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
29661     +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
29662     +         %let dsid = %sysfunc(close(&dsid));
29663     +      %end;
29665     +      %global ignbintarget;
29666     +      %let ignbintarget = %EM_BINARY_TARGET;
29668     +      data &EM_USER_NEWTRAIN;
29669     +        set &EM_IMPORT_DATA;
29670     +      run;
29671     +   %end;
29672     +   %else %do; /* preprocessing for interval target */
29673     +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
29674     +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
29675     +            var &target_var;
29676     +         run;
29678     +         data _null_;
29679     +            set minmax;
29680     +            call symput('tarmax',strip(max));
29681     +            call symput('tarmin',strip(min));
29682     +         run;
29684     +         /* cutoff can equal tarmin but not tarmax */
29685     +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or %sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
29686     +            %let EMEXCEPTIONSTRING = exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
29687     +            %put &em_codebar;
29688     +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error, NOQUOTE, &tarmin, &tarmax));
29689     +            %put &errormsg;
29690     +            %put &em_codebar;
29691     +            %goto doendm;
29692     +         %end;
29693     +      %end;
29695     +      %global ignbintarget;
29696     +      %getVarName(&EM_IMPORT_DATA, BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))), IGNBinTarget);
29698     +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLevels=igntbinlevs);
29699     +      %if &igntbinlevs ne 2 %then %do;
29700     +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
29701     +         %put &em_codebar;
29702     +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error, NOQUOTE));
29703     +         %put &errormsg;
29704     +         %put &em_codebar;
29705     +         %goto doendm;
29706     +      %end;
29708     +      %let Target_Event = 1;
29709     +      %let Target_NonEvent = 0;
29710     +      %let Target_Type = BINARY;
29711     +      %let Target_Format = ;
29713     +   %end;
29715     +   /* data sets */
29716     +   %EM_GETNAME(key=BINDATA,        type=DATA);
29717     +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
29718     +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
29719     +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
29720     +   %EM_GETNAME(key=COARSE,          type=DATA);
29721     +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
29722     +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
29724     +   /* files */
29725     +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
29726     +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
29728     +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
29729     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
29730     +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
29731     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
29732     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE));
29734     +        %put &em_codebar;
29735     +        %put &errmsg;
29736     +        %put &em_codebar;
29737     +        %goto doendm;
29738     +     %end;
29739     +   %end;
29741     +   %global useImport;
29742     +   %let useImport = 0;
29744     +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
29746     +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
29747     +     proc datasets library=&EM_LIB nolist;
29748     +       delete &EM_NODEID._IMPORTSUBSET;
29749     +     run;
29750     +     quit;
29751     +   %end;
29753     +   /* if importGrouping=Y, verify that data and all vars exist and are of the correct type */
29754     +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
29756     +     /* if import eq Y and no importtable exists, throw an exception */
29757     +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
29758     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
29759     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
29761     +        %put &em_codebar;
29762     +        %put &errmsg;
29763     +        %put &em_codebar;
29764     +        %goto doendm;
29765     +     %end;
29767     +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
29768     +      %if &dsid %then %do;
29769     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
29770     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
29771     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
29772     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
29774     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
29775     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
29776     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
29777     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
29778     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
29779     +         %end;
29780     +      %end;
29781     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29783     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
29784     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
29786     +        /* generate subset of data that contains those vars also found in training data and add display_var information */
29787     +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
29788     +           by _VARIABLE_ ;
29789     +        run;
29791     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
29792     +          by NAME;
29793     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
29794     +        run;
29796     +        data &EM_USER_IMPORTSUBSET;
29797     +          merge tempimport(in=_a) tempvarset(in=_b);
29798     +          length display_Var $32;
29799     +          by _VARIABLE_;
29800     +          display_var = _Variable_;
29801     +          if _a and _b then output;
29802     +        run;
29804     +        proc datasets library=work nolist;
29805     +          delete tempimport tempvarset;
29806     +        run;
29807     +        quit;
29809     +        %end;
29810     +      %end;
29811     +   %end;
29813     +   /* set useImport flag if there are obs in the importSubset dataset */
29814     +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
29815     +   %if &dsid %then %do;
29816     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
29817     +     %if &nobs gt 0 %then %let useimport = 1;
29818     +   %end;
29819     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29821     +   %global useFreeze;
29822     +   %let useFreeze = 0;
29824     +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type */
29825     +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
29827     +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
29828     +     proc datasets library=&EM_LIB nolist;
29829     +       delete &EM_NODEID._FREEZESUBSET;
29830     +     run;
29831     +     quit;
29832     +   %end;
29834     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
29836     +      /* create freezesubset data to contain information on pre-binned data and raw values */
29837     +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
29839     +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
29840     +      %if &dsid %then %do;
29841     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
29842     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
29843     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
29844     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
29846     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
29847     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
29848     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
29849     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
29850     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
29851     +         %end;
29852     +      %end;
29853     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29855     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
29856     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
29858     +        /* generate subset of data that contains those vars also found in training data */
29859     +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
29860     +           by _VARIABLE_ ;
29861     +        run;
29863     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
29864     +          by NAME;
29865     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
29866     +        run;
29868     +        data &EM_USER_FREEZESUBSET;
29869     +          merge tempfreeze(in=_a) tempvarset(in=_b);
29870     +          length display_Var $32;
29871     +          by _VARIABLE_;
29872     +          display_var = _Variable_;
29873     +          if _a and _b then output;
29874     +        run;
29876     +        proc datasets library=work nolist;
29877     +          delete tempfreeze tempvarset;
29878     +        run;
29879     +        quit;
29880     +        %end;
29881     +      %end;
29882     +   %end;
29884     +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
29885     +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
29886     +   %if &dsid %then %do;
29887     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
29888     +     %if &nobs gt 0 %then %let useFreeze = 1;
29889     +   %end;
29890     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29892     +   /* if finedetail already exists, delete prior to re-run */
29893     +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
29894     +     proc datasets library=&EM_LIB nolist;
29895     +       delete &EM_NODEID._FINEDETAILDATA;
29896     +     run;
29897     +     quit;
29898     +   %end;
29900     +   data tempvarnames;
29901     +     set &EM_DATA_VARIABLESET;
29902     +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
29903     +     keep NAME LEVEL LABEL;
29904     +   run;
29906     +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
29907     +     names NAME;
29908     +     prefix WOE_ GRP_ ;
29909     +   run;
29911     +   proc sort data=tempmapping; by name; run;
29912     +   proc sort data=tempvarnames; by name; run;
29913     +   data tempmapping;
29914     +     merge tempmapping tempvarnames;
29915     +     by NAME;
29916     +     rename LEVEL=procLevel;
29917     +   run;
29919     +   /* generate initial columns of mapping table by setting grpflag=0 */
29920     +   %EM_GENERATE_MAPPING_TABLE;
29922     +   proc datasets library=work nolist;
29923     +     delete tempImport tempScore;
29924     +   run;
29925     +   quit;
29927     +   /* delete splitvals dataset if this existed prior to run */
29928     +   %let nvars=0;
29929     +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
29930     +   %if &sdsid > 0 %then %do;
29931     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
29932     +   %end;
29933     +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
29935     +   %if &nvars > 0 %then %do;
29936     +      proc datasets library=&EM_LIB nolist;
29937     +        delete &EM_NODEID._SPLITVALS;
29938     +      run;
29939     +      quit;
29940     +   %end;
29942     +   %global classvars qclassvars;
29943     +   %let classvars=;
29944     +   %let qclassvars=;
29946     +   /* generate the intervalvars and classvars macros */
29947     +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
29949     +   /* update varmappings with any changes to procLevel based on discretemid */
29950     +   data &EM_USER_VARMAPPINGS;
29951     +     set &EM_USER_VARMAPPINGS;
29952     +     /* procLevel column to indicate the level used by proc; this handles*/
29953     +     /* cases in which var is marked INTERVAL in metadat but treated as  */
29954     +     /* ordinal in prebinning because of # unique levels                 */
29955     +     %let dsid = %sysfunc(open(work._discretemid));
29956     +     %if &dsid %then %do;
29957     +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
29958     +       %let obs = %sysfunc(fetch(&dsid));
29959     +       %do %while(&obs=0);
29960     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
29961     +          if _variable_ = "&varname" then procLevel = "ORDINAL";
29962     +          %let obs = %sysfunc(fetch(&dsid));
29963     +       %end;
29964     +     %end;
29965     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
29966     +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel , NOQUOTE))";
29967     +   run;
29969     +   /* generate Grp_xxx variables for interval inputs */
29970     +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
29971     +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
29973     +   %end;
29974     +   %else %do;
29975     +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
29976     +   %end;
29978     +   /* generate GRP_XXX variables for nominal inputs */
29979     +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
29981     +   /* generate GRP_XXX variables for ordinal inputs */
29982     +   %EM_ORDVARS_GROUP;
29984     +   proc print data=&EM_USER_VARMAPPINGS label;
29985     +     var _VARIABLE_ _GRP_VARIABLE_ ;
29986     +   run;
29988     +   /* add _proc_var_ to varmappings data to know names of processed variables; could be original input, could be bin_xxx */
29989     +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
29990     +     by _VARIABLE_;
29991     +   run;
29993     +   data &EM_USER_VARMAPPINGS;
29994     +     set &EM_USER_VARMAPPINGS;
29995     +     length _proc_var_ $32;
29996     +     %let dsid = %sysfunc(open(work.tempsplitvals));
29997     +     %if &dsid %then %do;
29998     +        %let obs = %sysfunc(fetch(&dsid));
29999     +        %do %while(&obs=0);
30000     +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
30001     +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
30002     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
30003     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
30005     +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
30006     +          %let obs = %sysfunc(fetch(&dsid));
30007     +        %end;
30008     +     %end;
30009     +     if missing(_proc_var_) then _proc_var_=_variable_;
30010     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30011     +   run;
30013     +   proc datasets library=work nolist;
30014     +     delete sortedbin tempsplitvals;
30015     +   run;
30016     +   quit;
30018     +   /* calculate Fine Detail statistics for each input */
30019     +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
30021     +   /* apply grouping and create grouped dataset */
30022     +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
30024     +   /* generate _label_ values in the COARSE dataset from the Scored data */
30025     +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
30026     +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS, &EM_USER_COARSE);
30027     +   filename Y;
30029     +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
30030     +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
30032     +   /* generate reports */
30033     +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT, autodisplay=N, spk=N);
30036     +   %doendm:
30037     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
30039     +%macro EM_GENERATE_MAPPING_TABLE;
30041     +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
30042     +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
30043     +   length _variable_  _grp_variable_  $32 procLevel $8;
30044     +   set tempmapping;
30045     +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel , NOQUOTE))"
30046     +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel , NOQUOTE))";
30048     +         _variable_ = NAME;
30049     +         _grp_variable_ = GRP;
30050     + run;
30052     +%mend EM_GENERATE_MAPPING_TABLE;
30054     +%macro EM_PRE_BINNING(input);
30055     +    /* Determine which of our variables are interval  */
30057     +    data tempvariableset;
30058     +      set &EM_DATA_VARIABLESET;
30059     +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
30060     +    run;
30062     +    /* add all interval vars to the intervalvar macro
30063     +    %let dsid = %sysfunc(open(work.tempvariableset));
30064     +    %if &dsid %then %do;
30065     +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
30066     +       %let obs = %sysfunc(fetch(&dsid));
30067     +       %do %while(&obs=0);
30068     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
30069     +          %let intervalvars = &intervalvars &varname;
30070     +          %let obs = %sysfunc(fetch(&dsid));
30071     +       %end;
30072     +    %end;
30073     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30074     + */
30076     +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME, nummacro=num_intvars);
30078     +    /* Determine which variables marked as interval are true interval distributions; */
30079     +    /* intmid contains variables that are actually interval and should be binned; */
30080     +    /* discretemid contains variables that are actually discrete and should NOT be binned */
30081     +    %if %intervalvars ne %then %do;
30082     +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
30083     +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
30084     +        class %intervalvars;
30085     +      run;
30086     +      proc freq data=_CLASSOUT order=DATA noprint;
30087     +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
30088     +      run;
30090     +      %let _INTBINS=;
30091     +      data _null_;
30092     +        set _COUNT;
30093     +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
30094     +      run;
30096     +      proc sort data=_CLASSOUT;
30097     +        by NAME;
30098     +      run;
30099     +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
30100     +        var NRAW;
30101     +        by NAME;
30102     +      run;
30104     +      data _null_;
30105     +        dsid = open('_OUT');
30106     +        if dsid then do;
30107     +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
30108     +           csid = close(dsid);
30109     +        end;
30110     +      run;
30111     +      data _INTMID;
30112     +        set _OUT;
30113     +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
30114     +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
30115     +          if ^indexw("&_INTBINS", VARIABLE) then output;
30116     +        %end;
30117     +      run;
30119     +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
30120     +        data _DISCRETEMID;
30121     +          set _OUT;
30122     +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
30123     +          if indexw("&_INTBINS", VARIABLE) then output;
30124     +        run;
30125     +      %end;
30126     +      %else %do;
30127     +         %if %sysfunc(exist(_discretemid)) %then %do;
30128     +            proc delete data=_discretemid;
30129     +            run;
30130     +         %end;
30131     +      %end;
30133     +      /* add vars from the _DISCRETEMID dataset to the classvars macro
30134     +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
30135     +      %if &dsid %then %do;
30136     +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
30137     +        %let obs = %sysfunc(fetch(&dsid));
30139     +        %do %while(&obs=0);
30140     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
30141     +          %let classvars = &classvars &var;
30142     +          %let qclassvars = &qclassvars "&var";
30143     +          %let obs = %sysfunc(fetch(&dsid));
30144     +        %end;
30145     +      %end;
30146     +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
30147     +*/
30148     +    %end;
30149     +    %else %do;
30150     +      %if %sysfunc(exist(_intmid)) %then %do;
30151     +         proc delete data=_intmid;
30152     +         run;
30153     +      %end;
30155     +      %if %sysfunc(exist(_discretemid)) %then %do;
30156     +         proc delete data=_discretemid;
30157     +         run;
30158     +      %end;
30159     +    %end;
30161     +    /* if import grouping then remove interval vars in import data from _INTMID */
30162     +    %if &useImport eq 1 %then %do;
30164     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
30165     +        by _VARIABLE_;
30166     +      run;
30168     +      data &EM_USER_IMPORTSUBSET;
30169     +        length CODEVAR $32;
30170     +        set &EM_USER_IMPORTSUBSET;
30171     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
30172     +      run;
30174     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
30175     +        by _VARIABLE_;
30176     +      run;
30178     +      %let dsid = %sysfunc(open(work.tempsubset));
30179     +      %let nobs = 0;
30180     +      %if &dsid %then %do;
30181     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
30182     +      %end;
30183     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
30185     +      data tempsubset;
30186     +        set tempsubset;
30187     +        length  binVar suffix $32;
30188     +        array binnames{&nobs} $32 _temporary_;
30189     +        retain binVar binnames;
30190     +        by _VARIABLE_;
30192     +        binVar = 'BIN_'!!strip(CODEVAR);
30193     +        binVar = ksubstr(binVar, 1, 32);
30194     +        count = 1;
30196     +        do i=1 to _N_;
30197     +           do while(binvar eq binnames(i));
30198     +              suffix = strip(put(count,best.));
30199     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
30200     +              count + 1;
30201     +           end;
30202     +        end;
30203     +        binnames(_N_)= binvar;
30204     +        output;
30205     +        drop suffix count i;
30206     +     run;
30208     +     data &EM_USER_IMPORTSUBSET;
30209     +       set &EM_USER_IMPORTSUBSET;
30210     +       length binVar $32;
30212     +        %let dsid = %sysfunc(open(work.tempsubset));
30213     +        %if &dsid %then %do;
30214     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
30215     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
30216     +          %let obs = %sysfunc(fetch(&dsid));
30218     +          %do %while(&obs=0);
30219     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
30220     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
30222     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
30223     +            %let obs = %sysfunc(fetch(&dsid));
30224     +          %end;
30225     +        %end;
30226     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30227     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
30228     +        if binVar ne "" then do;
30229     +          _LEVEL_ = "ORDINAL";
30230     +        end;
30232     +      run;
30234     +      %let idsidexists=0;
30235     +      %let idsid = %sysfunc(open(work._intmid));
30236     +      %if &idsid %then %do;
30237     +        %let idsidexists=1;
30238     +        %let idsid = %sysfunc(close(&idsid));
30239     +      %end;
30241     +      %if &idsidexists = 1 %then %do;
30242     +      data _INTMID;
30243     +        set _INTMID;
30245     +        %let dsid = %sysfunc(open(work.tempsubset));
30246     +        %if &dsid %then %do;
30247     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
30248     +          %let obs = %sysfunc(fetch(&dsid));
30250     +          %do %while(&obs=0);
30251     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
30252     +            if variable = "&codevar" then delete;
30253     +            %let obs = %sysfunc(fetch(&dsid));
30254     +          %end;
30255     +        %end;
30256     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30257     +      run;
30258     +      %end;
30260     +      proc datasets library=work nolist;
30261     +        delete tempsubset;
30262     +      run;
30263     +      quit;
30264     +    %end;
30266     +    /* if freeze then remove interval vars in import data from _INTMID */
30267     +    %if &useFreeze eq 1 %then %do;
30269     +      data &EM_USER_FREEZESUBSET;
30270     +        length CODEVAR $32;
30271     +        set &EM_USER_FREEZESUBSET;
30272     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
30273     +      run;
30275     +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
30276     +        by _VARIABLE_;
30277     +      run;
30279     +      %let dsid = %sysfunc(open(work.tempsubset));
30280     +      %let nobs = 0;
30281     +      %if &dsid %then %do;
30282     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
30283     +      %end;
30284     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
30286     +      data tempsubset;
30287     +        set tempsubset;
30288     +        length  binVar suffix $32;
30289     +        array binnames{&nobs} $32 _temporary_;
30290     +        retain binVar binnames;
30291     +        by _VARIABLE_;
30293     +        binVar = 'BIN_'!!strip(CODEVAR);
30294     +        binVar = ksubstr(binVar, 1, 32);
30295     +        count = 1;
30297     +        do i=1 to _N_;
30298     +           do while(binvar eq binnames(i));
30299     +              suffix = strip(put(count,best.));
30300     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
30301     +              count + 1;
30302     +           end;
30303     +        end;
30304     +        binnames(_N_)= binvar;
30305     +        output;
30306     +        drop suffix count i;
30307     +     run;
30309     +     data &EM_USER_FREEZESUBSET;
30310     +       set &EM_USER_FREEZESUBSET;
30311     +       length binVar $32;
30313     +        %let dsid = %sysfunc(open(work.tempsubset));
30314     +        %if &dsid %then %do;
30315     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
30316     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
30317     +          %let obs = %sysfunc(fetch(&dsid));
30319     +          %do %while(&obs=0);
30320     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
30321     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
30323     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
30324     +            %let obs = %sysfunc(fetch(&dsid));
30325     +          %end;
30326     +        %end;
30327     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30329     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
30330     +        if binVar ne "" then do;
30331     +          _LEVEL_ = "ORDINAL";
30332     +        end;
30334     +      run;
30336     +      %let idsidexists= 0;
30337     +      %let idsid = %sysfunc(open(work._intmid));
30338     +      %if &idsid %then %do;
30339     +        %let idsidexists=1;
30340     +        %let idsid = %sysfunc(close(&idsid));
30341     +      %end;
30342     +      %if &idsidexists eq 1 %then %do;
30343     +      data _INTMID;
30344     +        set _INTMID;
30346     +        %let dsid = %sysfunc(open(work.tempsubset));
30347     +        %if &dsid %then %do;
30348     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
30349     +          %let obs = %sysfunc(fetch(&dsid));
30351     +          %do %while(&obs=0);
30352     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
30353     +            if variable = "&codevar" then delete;
30354     +            %let obs = %sysfunc(fetch(&dsid));
30355     +          %end;
30356     +        %end;
30357     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30358     +      run;
30359     +      %end;
30361     +      proc datasets library=work nolist;
30362     +        delete tempsubset;
30363     +      run;
30364     +      quit;
30366     +    %end;
30368     +%mend EM_PRE_BINNING;
30370     +%macro EM_IMPORT_BINNING(binningCode);
30373     +   data tempintimport;
30374     +     set &EM_USER_IMPORTSUBSET;
30375     +     if binflag = 1;
30376     +   run;
30378     +   %let idsid = %sysfunc(open(work.tempintimport));
30379     +   %if &idsid %then %do;
30380     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
30381     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
30382     +   %end;
30383     +   %else %do;
30384     +     %let nvars = 0;
30385     +     %let nobs = 0;
30386     +   %end;
30387     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
30389     +   proc datasets library=work nolist;
30390     +     delete tempintimport;
30391     +   run;
30392     +   quit;
30394     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
30396     +      filename X "&binningCode";
30397     +      data _null_;
30398     +        FILE X MOD;
30399     +        %let bin_variables=;
30400     +        %let quote_bin_variables = ;
30401     +        %let choice = binflag = 1;
30402     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
30403     +        %if &dsid %then %do;
30404     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
30405     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
30406     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
30407     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note , NOQUOTE));
30409     +           put "&EM_CODEBAR;";
30410     +           put " &note; ";
30411     +           put "&EM_CODEBAR;";
30413     +           /* retrieve value for first obs */
30414     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
30415     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
30416     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
30418     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
30419     +           %let i = 1;
30420     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
30421     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
30422     +           %end;
30423     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
30424     +           put " ";
30425     +           put "if &oldname eq . then &binvalue = .;";
30427     +           /* cycle through special codes if they exist */
30428     +           %let index2 = %index(&oldname, SV_);
30429     +           %if &index2 gt 0 %then %do;
30430     +             %let choice = CODEVAR ="&oldname";
30431     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
30432     +             %if &cdsid %then %do;
30433     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
30434     +                %let cobs = %sysfunc(fetch(&cdsid));
30435     +                %do %while(&cobs=0);
30436     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
30437     +                    put "else if &oldname eq &code then &binvalue = &code;";
30438     +                   %let cobs = %sysfunc(fetch(&cdsid));
30439     +                %end;
30440     +             %end;
30441     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
30442     +           %end;
30443     +           put "else ";
30444     +           %if "&value" eq "." %then %do;
30445     +             put " &binvalue=&i;";
30446     +           %end;
30447     +           %else %do;
30448     +             put "  if &oldname < &value then &binvalue=&i;";
30449     +           %end;
30451     +           %let i= %eval(&i+1);
30453     +           %let obs = %sysfunc(fetch(&dsid));
30454     +           %do %while(&obs=0);
30455     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
30456     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
30457     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
30459     +              %if "&oldname" ne "&namevalue" %then %do;
30461     +                /* if variable has been re-coded for special codes, must include these values as well */
30462     +                put;
30463     +                put "if &namevalue eq . then &binvalue = .;";
30465     +                %let i=1;
30466     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
30467     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
30468     +                %end;
30469     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
30471     +                /* cycle through special codes if they exist */
30472     +                %let index2 = %index(&namevalue, SV_);
30473     +                %if &index2 gt 0 %then %do;
30474     +                  %let choice = CODEVAR ="&namevalue";
30475     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
30476     +                  %if &cdsid %then %do;
30477     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
30478     +                     %let cobs = %sysfunc(fetch(&cdsid));
30479     +                     %do %while(&cobs=0);
30480     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
30481     +                       put "else if &namevalue eq &code then &binvalue = &code;";
30482     +                       %let cobs = %sysfunc(fetch(&cdsid));
30483     +                     %end;
30484     +                  %end;
30485     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
30486     +                %end;
30487     +                put "else ";
30488     +                %if "&value" ne "." %then %do;
30489     +                  put "  if &namevalue < &value then &binvalue=&i;";
30490     +                %end;
30491     +                %else %do;
30492     +                  put " &binvalue=&i;";
30493     +                %end;
30495     +              %end;
30496     +              %else %do;
30497     +                put "else ";
30498     +                %if "&value" ne "." %then %do;
30499     +                  put "  if &namevalue < &value then &binvalue=&i;";
30500     +                %end;
30501     +                %else %do;
30502     +                  put "  &binvalue=&i;";
30503     +                %end;
30504     +              %end;
30505     +              %let i = %eval(&i + 1);
30506     +              %let obs = %sysfunc(fetch(&dsid));
30507     +              %let oldname = &namevalue;
30508     +              %let oldbinvalue = &binvalue;
30509     +           %end;
30510     +        %end;
30511     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
30513     +      run;
30514     +      filename X;
30515     +      /* generate BINMAPPINGS dataset */
30516     +      data TEMPBINMAPPINGS;
30517     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
30519     +        %let choice = binflag = 1;
30520     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
30521     +        %if &dsid %then %do;
30522     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
30523     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
30524     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
30525     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
30526     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
30528     +           /* retrieve information from first obs */
30529     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
30530     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
30531     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
30532     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
30533     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
30534     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
30535     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
30536     +           %let i = 1;
30538     +           NAME = "&OLDCODEVAR";
30539     +           BIN_NAME = "&OLDBINVAR";
30540     +           GRP_NAME = "&OLDGRPVAR";
30541     +           BIN = "&i";
30542     +           GRP = "&oldgrpvalue";
30543     +           LB = . ;
30544     +           UB = &oldvalue;
30545     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
30546     +           DISPLAY_VAR = "&oldvar";
30547     +           output;
30549     +           %let i = 2;
30550     +           %let obs = %sysfunc(fetch(&dsid));
30551     +           %do %while(&obs=0);
30552     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
30553     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
30554     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
30555     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
30556     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
30557     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
30559     +             %if "&oldvar" ne "&var" %then %do;
30560     +              %let i = 1;
30561     +               %let oldvalue = .;
30562     +             %end;
30564     +             NAME = "&CODEVAR";
30565     +             BIN_NAME = "&BINVAR";
30566     +             GRP_NAME = "&GRPVAR";
30567     +             BIN = "&i";
30568     +             GRP = "&group";
30569     +             LB = &oldvalue ;
30570     +             UB = &value;
30571     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
30572     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
30573     +             %end;
30574     +             %else %do;
30575     +               %if "&oldvalue" eq "." %then %do;
30576     +                 EM_BIN_LABEL = "&var < &value" ;
30577     +               %end;
30578     +               %if "&value" eq "." %then %do;
30579     +                 EM_BIN_LABEL = "&oldvalue >= &var";
30580     +               %end;
30581     +             %end;
30582     +             DISPLAY_VAR = "&var";
30583     +             output;
30585     +             %let oldvar = &var;
30586     +             %let oldcodevar = &codevar;
30587     +             %let oldbinvar = &binvar;
30588     +             %let oldgrpvar = &grpvar;
30589     +             %let oldvalue   = &value;
30590     +             %let oldgrpvalue   = &group;
30591     +             %let i = %eval(&i + 1);
30592     +             %let obs = %sysfunc(fetch(&dsid));
30593     +           %end;
30594     +        %end;
30595     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
30596     +      run;
30598     +      data &EM_USER_BINMAPPINGS;
30599     +        set &EM_USER_BINMAPPINGS tempBinMappings;
30600     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
30601     +      run;
30603     +      /* update importsubset with bin values instead of raw values */
30604     +      data &EM_USER_IMPORTSUBSET;
30605     +        set &EM_USER_IMPORTSUBSET;
30607     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
30608     +        %if &dsid %then %do;
30609     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
30610     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
30611     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
30612     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
30613     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
30614     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
30616     +          %let oldvar = ;
30617     +          %let obs = %sysfunc(fetch(&dsid));
30618     +          %do %while(&obs=0);
30619     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
30620     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
30621     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
30622     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
30623     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
30624     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
30626     +            %if "&oldvar" eq "&displayvar" %then %do;
30627     +              else
30628     +            %end;
30629     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
30630     +               _SPLIT_VALUE_ = "&bin";
30631     +            end;
30632     +            %let oldvar = &displayvar;
30633     +            %let obs = %sysfunc(fetch(&dsid));
30634     +          %end;
30635     +        %end;
30636     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30637     +      run;
30639     +      proc sort data=&EM_USER_IMPORTSUBSET;
30640     +        by _VARIABLE_ _SPLIT_VALUE_;
30641     +      run;
30643     +      proc datasets library=work nolist;
30644     +        delete tempBinMappings;
30645     +      run;
30646     +      quit;
30647     +  %end;
30648     +%mend EM_IMPORT_BINNING;
30650     +%macro EM_FREEZE_BINNING(binningCode);
30652     +   data tempintfreeze;
30653     +     set &EM_USER_FREEZESUBSET;
30654     +     if binflag = 1;
30655     +   run;
30657     +   %let idsid = %sysfunc(open(work.tempintfreeze));
30658     +   %if &idsid %then %do;
30659     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
30660     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
30661     +   %end;
30662     +   %else %do;
30663     +     %let nvars = 0;
30664     +     %let nobs = 0;
30665     +   %end;
30666     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
30668     +   proc datasets library=work nolist;
30669     +     delete tempintimport;
30670     +   run;
30671     +   quit;
30673     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
30675     +      filename X "&binningCode";
30676     +      data _null_;
30677     +        FILE X MOD;
30679     +        %let bin_variables=.;
30680     +        %let quote_bin_variables=.;
30681     +        %let freeze_variables=;
30682     +        %let choice = binflag = 1;
30683     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
30684     +        %if &dsid %then %do;
30685     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
30686     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
30687     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
30688     +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
30690     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note , NOQUOTE));
30691     +           put "&EM_CODEBAR;";
30692     +           put "&note;";
30693     +           put "&EM_CODEBAR;";
30695     +           /* retrieve value for first obs */
30696     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
30697     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
30698     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
30699     +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
30701     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
30702     +           %let i = 1;
30703     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
30704     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
30705     +           %end;
30706     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
30707     +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
30709     +           put " ";
30710     +           put "if &oldname eq . then &binvalue = .;";
30712     +           /* cycle through special codes if they exist */
30713     +           %let index2 = %index(&oldname, SV_);
30714     +           %if &index2 gt 0 %then %do;
30715     +             %let choice = CODEVAR ="&oldname";
30716     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
30717     +             %if &cdsid %then %do;
30718     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
30719     +                %let cobs = %sysfunc(fetch(&cdsid));
30720     +                %do %while(&cobs=0);
30721     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
30722     +                    put "else if &oldname eq &code then &binvalue = &code;";
30723     +                   %let cobs = %sysfunc(fetch(&cdsid));
30724     +                %end;
30725     +             %end;
30726     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
30727     +           %end;
30728     +           put "else ";
30729     +           %if "&value" eq "." %then %do;
30730     +             put " &binvalue=&i;";
30731     +           %end;
30732     +           %else %do;
30733     +             put "  if &oldname < &value then &binvalue=&i;";
30734     +           %end;
30736     +           %let i= %eval(&i+1);
30738     +           %let obs = %sysfunc(fetch(&dsid));
30739     +           %do %while(&obs=0);
30740     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
30741     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
30742     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
30743     +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
30745     +              %if "&oldname" ne "&namevalue" %then %do;
30747     +                /* if variable has been re-coded for special codes, must include these values as well */
30748     +                put;
30749     +                put "if &namevalue eq . then &binvalue = .;";
30751     +                %let i=1;
30752     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
30753     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
30754     +                %end;
30755     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
30756     +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
30758     +                /* cycle through special codes if they exist */
30759     +                %let index2 = %index(&namevalue, SV_);
30760     +                %if &index2 gt 0 %then %do;
30761     +                  %let choice = CODEVAR ="&namevalue";
30762     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
30763     +                  %if &cdsid %then %do;
30764     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
30765     +                     %let cobs = %sysfunc(fetch(&cdsid));
30766     +                     %do %while(&cobs=0);
30767     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
30768     +                       put "else if &namevalue eq &code then &binvalue = &code;";
30769     +                       %let cobs = %sysfunc(fetch(&cdsid));
30770     +                     %end;
30771     +                  %end;
30772     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
30773     +                %end;
30774     +                put "else ";
30775     +                %if "&value" ne "." %then %do;
30776     +                  put "  if &namevalue < &value then &binvalue=&i;";
30777     +                %end;
30778     +                %else %do;
30779     +                  put " &binvalue=&i;";
30780     +                %end;
30782     +              %end;
30783     +              %else %do;
30784     +                put "else ";
30785     +                %if "&value" ne "." %then %do;
30786     +                  put "  if &namevalue < &value then &binvalue=&i;";
30787     +                %end;
30788     +                %else %do;
30789     +                  put " &binvalue=&i;";
30790     +                %end;
30791     +              %end;
30792     +              %let i = %eval(&i + 1);
30793     +              %let obs = %sysfunc(fetch(&dsid));
30794     +              %let oldname = &namevalue;
30795     +              %let oldbinvalue = &binvalue;
30796     +           %end;
30797     +        %end;
30798     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
30800     +      run;
30801     +      filename X;
30802     +      /* generate BINMAPPINGS dataset */
30803     +      data TEMPBINMAPPINGS;
30804     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
30806     +        %let choice = binflag = 1;
30807     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
30808     +        %if &dsid %then %do;
30809     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
30810     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
30811     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
30812     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
30813     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
30815     +           /* retrieve information from first obs */
30816     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
30817     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
30818     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
30819     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
30820     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
30821     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
30822     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
30823     +           %let i = 1;
30825     +           NAME = "&OLDCODEVAR";
30826     +           BIN_NAME = "&OLDBINVAR";
30827     +           GRP_NAME = "&OLDGRPVAR";
30828     +           BIN = "&i";
30829     +           GRP = "&oldgrpvalue";
30830     +           LB = . ;
30831     +           UB = &oldvalue;
30832     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
30833     +           DISPLAY_VAR = "&oldvar";
30834     +           output;
30836     +           %let i = 2;
30837     +           %let obs = %sysfunc(fetch(&dsid));
30838     +           %do %while(&obs=0);
30839     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
30840     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
30841     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
30842     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
30843     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
30844     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
30846     +             %if "&oldvar" ne "&var" %then %do;
30848     +               %let i = 1;
30849     +               %let oldvalue = .;
30850     +             %end;
30852     +             NAME = "&CODEVAR";
30853     +             BIN_NAME = "&BINVAR";
30854     +             GRP_NAME = "&GRPVAR";
30855     +             BIN = "&i";
30856     +             GRP = "&group";
30857     +             LB = &oldvalue ;
30858     +             UB = &value;
30859     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
30860     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
30861     +             %end;
30862     +             %else %do;
30863     +               %if "&oldvalue" eq "." %then %do;
30864     +                 EM_BIN_LABEL = "&var < &value" ;
30865     +               %end;
30866     +               %if "&value" eq "." %then %do;
30867     +                 EM_BIN_LABEL = "&oldvalue >= &var";
30868     +               %end;
30869     +             %end;
30870     +             DISPLAY_VAR = "&var";
30871     +             output;
30873     +             %let oldvar = &var;
30874     +             %let oldcodevar = &codevar;
30875     +             %let oldbinvar = &binvar;
30876     +             %let oldgrpvar = &grpvar;
30877     +             %let oldvalue   = &value;
30878     +             %let oldgrpvalue = &group;
30879     +             %let i = %eval(&i + 1);
30880     +             %let obs = %sysfunc(fetch(&dsid));
30881     +           %end;
30882     +        %end;
30884     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
30885     +      run;
30887     +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings -- prevents duplicate entries */
30888     +      data &EM_USER_BINMAPPINGS;
30889     +        set &EM_USER_BINMAPPINGS;
30890     +        if NAME in (&FREEZE_VARIABLES) then delete;
30891     +      run;
30893     +      data &EM_USER_BINMAPPINGS;
30894     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
30896     +        set &EM_USER_BINMAPPINGS tempBinMappings;
30897     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
30898     +      run;
30900     +      /* update freezesubset with bin values instead of raw values */
30901     +      data &EM_USER_FREEZESUBSET;
30902     +        set &EM_USER_FREEZESUBSET;
30904     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
30905     +        %if &dsid %then %do;
30906     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
30907     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
30908     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
30909     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
30910     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
30911     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
30913     +          %let oldvar = ;
30914     +          %let obs = %sysfunc(fetch(&dsid));
30915     +          %do %while(&obs=0);
30916     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
30917     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
30918     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
30919     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
30920     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
30921     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
30923     +            %if "&oldvar" eq "&displayvar" %then %do;
30924     +              else
30925     +            %end;
30926     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
30927     +               _SPLIT_VALUE_ = "&bin";
30928     +            end;
30929     +            %let oldvar =&displayvar;
30930     +            %let obs = %sysfunc(fetch(&dsid));
30931     +          %end;
30932     +        %end;
30933     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30934     +      run;
30936     +      proc sort data=&EM_USER_FREEZESUBSET;
30937     +        by _VARIABLE_ _SPLIT_VALUE_;
30938     +      run;
30940     +      proc datasets library=work nolist;
30941     +        delete tempBinMappings;
30942     +      run;
30943     +      quit;
30944     +   %end;
30945     +%mend EM_FREEZE_BINNING;
30947     +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
30950     +/* initialize new bucket_binning macro */
30951     +filename temp catalog 'sashelp.emapps.bucket_binning.source';
30952     +%include temp;
30953     +filename temp;
30955     +/* create fileref for generation of binningCode */
30956     +filename X "&binningCode";
30958     +/* determine if there are inputs to be binned */
30959     +%let numbinvars = 0;
30960     +%let intdsid = %sysfunc(open(work._intmid));
30961     +%if &intdsid %then %do;
30962     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
30963     +%end;
30964     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
30965     +%if &numbinvars > 0 %then %do;
30968     +/* get data in format needed for quantile_binning macro */
30969     +data work.vartable;
30970     +  set work._intmid;
30971     +  level = "INTERVAL";
30972     +  role  = "INPUT";
30973     +  rename variable=name;
30974     +run;
30976     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
30977     +%if %EM_FREQ ne %then %do;
30978     +   data work.freq;
30979     +     name="%EM_FREQ";
30980     +     role="FREQ";
30981     +   run;
30983     +   data work.vartable;
30984     +     set work.vartable work.freq;
30985     +   run;
30986     +%end;
30988     +/* perform bucket binning of data */
30989     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
30990     +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
30992     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
30993     +%end;
30994     +%else %do;
30995     +  /* initialize binmappings table */
30996     +  data &EM_USER_BINMAPPINGS;
30997     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
30998     +  run;
31000     +  data _null_;
31001     +    FILE X;
31003     +    put "&EM_CODEBAR;";
31004     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
31005     +    put "* &note;";
31006     +    put "&EM_CODEBAR;";
31007     +  run;
31009     +%end;
31011     +/* assign display_var values to binmappings table as well as initial group values */
31012     +data &EM_USER_BINMAPPINGS;
31013     +  set &EM_USER_BINMAPPINGS;
31014     +  length display_var $32 grp $8;
31015     +  display_var = name;
31017     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31018     +    GRP = BIN + 1;
31019     +  %end;
31020     +  %else %do;
31021     +    GRP = BIN;
31022     +  %end;
31023     +run;
31025     +/* de-assign fileref */
31026     +filename X;
31028     +    /* append to binning code those values that were included in the importSubset data */
31029     +    %if &useImport eq 1 %then %do;
31030     +      %EM_IMPORT_BINNING(&binningcode);
31031     +    %end;
31033     +    /* append to binning code those values that were included in the freezeSubset data */
31034     +    %if &useFreeze eq 1 %then %do;
31035     +      %EM_FREEZE_BINNING(&binningcode);
31036     +    %end;
31038     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
31039     +     by NAME;
31040     +     run;
31042     +     /* create grouping for missing level */
31043     +    data tempmissvalues;
31044     +    run;
31046     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31047     +       data tempmissvalues;
31048     +         %if &useImport eq 1 %then %do;
31049     +           merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
31050     +         %end;
31051     +         %if &useFreeze eq 1 %then %do;
31052     +           merge sortedmapping &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
31053     +         %end;
31054     +         %else %do;
31055     +           set sortedmapping;
31056     +         %end;
31057     +         GRP="1";
31058     +         bin="Missing";
31059     +         _split_value_ = "Missing";
31060     +         %if &useImport eq 1 %then %do;
31061     +            if _a then delete;
31062     +         %end;
31063     +         %if &useFreeze eq 1 %then %do;
31064     +            if _b then delete;
31065     +         %end;
31067     +       run;
31068     +    %end;
31070     +    /* create binData from binningCode */
31071     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
31072     +      by NAME;
31073     +    run;
31075     +    filename X "&binningCode";
31076     +    data &bindata;
31077     +      set &input;
31078     +      %inc X;
31079     +    run;
31081     +    filename X;
31083     +    /* create splitvals dataset */
31084     +    data tempsplitvals;
31085     +      set &EM_USER_BINMAPPINGS
31086     +        %let tdsid = %sysfunc(open(work.tempmissvalues));
31087     +        %if &tdsid %then %do;
31088     +          tempmissvalues
31089     +        %end;
31090     +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
31091     +      ;
31092     +      length newgroup _group_ 8 _level_ $8;
31093     +      newgroup =.;
31094     +      _LEVEL_ = 'ORDINAL';
31095     +      _Group_ = grp;
31096     +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
31097     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
31098     +    run;
31100     +    data tempsplitvals;
31101     +      set tempsplitvals;
31102     +      _order_ = _N_;
31103     +    run;
31105     +    /* determine if EM_USER_SPLITVALS already exists */
31106     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
31107     +    %if &sdsid > 0 %then %do;
31108     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
31109     +      %if &nvars > 0 %then %do;
31110     +        proc sql;
31111     +          reset noprint;
31112     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
31113     +        quit;
31114     +      %end;
31115     +      %else %let nobs=0;
31116     +    %end;
31117     +    %else %do;
31118     +       %let nobs=0;
31119     +       %let nvars=0;
31120     +    %end;
31121     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
31123     +    /* if useIMport=1 also include import definitions here as well */
31124     +    %if &useImport eq 1 %then %do;
31125     +      data tempImport;
31126     +        set &EM_USER_IMPORTSUBSET;
31127     +        _variable_ = binVar;
31128     +      run;
31129     +    %end;
31131     +    /* if useFreeze=1 also include import definitions here as well */
31132     +    %if &useFreeze eq 1 %then %do;
31133     +      data tempFreeze;
31134     +        length display_var $32;
31135     +        set &EM_USER_FREEZESUBSET;
31136     +        display_var = _variable_;
31137     +        _variable_ = binVar;
31138     +      run;
31139     +    %end;
31142     +    data &EM_USER_SPLITVALS;
31143     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
31144     +        set &EM_USER_SPLITVALS tempsplitvals
31145     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
31146     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
31147     +        %end;
31148     +        %if &useFreeze eq 1 %then %do;
31149     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
31150     +        %end;
31151     +        ;
31152     +      %end;
31153     +      %else %do;
31154     +        set tempsplitvals
31155     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
31156     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
31157     +        %end;
31158     +        %if &useFreeze eq 1 %then %do;
31159     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
31160     +        %end;
31161     +        ;
31162     +      %end;
31163     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
31164     +    run;
31166     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
31167     +    data tempvariableset;
31168     +      set &EM_DATA_VARIABLESET;
31169     +      where TYPE = 'C';
31170     +    run;
31172     +    /* add all interval vars that aren't special codes to the intervalvar macro
31173     +    %let dsid = %sysfunc(open(work.tempvariableset));
31174     +    %if &dsid %then %do;
31175     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31176     +      %let obs = %sysfunc(fetch(&dsid));
31177     +      %do %while(&obs=0);
31178     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
31179     +        %let classvars = &classvars &varname;
31180     +        %let qclassvars = &qclassvars "&varname";
31181     +        %let obs = %sysfunc(fetch(&dsid));
31182     +      %end;
31183     +    %end;
31184     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31185     +    */
31186     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
31188     +    %if %classvars ne %then %do;
31189     +      proc dmdb data =&bindata classout=_classout nonorm;
31190     +        class %classvars;
31191     +      run;
31193     +      proc dmdb data=&bindata classout=_classout2;
31194     +       class %classvars;
31195     +      run;
31197     +      proc sort data=_classout; by NAME CRAW; run;
31198     +      proc sort data=_classout2; by NAME CRAW; run;
31200     +      data _classout;
31201     +        length _variable_ $32;
31202     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
31203     +        _split_value_ = trim(left(_split_value_));
31204     +        LEVEL = trim(left(LEVEL));
31205     +        by NAME CRAW;
31206     +       _variable_ = NAME;
31207     +      run;
31209     +      proc sort data=_classout; by _variable_ _split_value_; run;
31210     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
31212     +      data &EM_USER_SPLITVALS;
31213     +        length _norm_level_ $200 _split_value_ $200;
31214     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
31215     +        by _variable_ _split_value_;
31216     +        LEVEL = trim(left(LEVEL));
31217     +        _norm_level_ = trim(left(_norm_level_));
31218     +        _split_value_ = trim(left(_split_value_));
31219     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
31220     +        drop NAME FREQUENCY TYPE CRAW NRAW;
31221     +      run;
31223     +      proc datasets library=work nolist;
31224     +        delete _classout _classout2;
31225     +      run;
31226     +      quit;
31227     +    %end;
31228     +    data &EM_USER_SPLITVALS;
31229     +      set &EM_USER_SPLITVALS;
31230     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
31231     +    run;
31233     +    proc sort data=&EM_USER_SPLITVALS;
31234     +      by DISPLAY_VAR _Group_;
31235     +    run;
31237     +   proc datasets library=work nolist;
31238     +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals sortedmapping tempmissvalues
31239     +      %if &useImport eq 1 %then %do;
31240     +        tempImport
31241     +      %end;
31242     +      %if &useFreeze eq 1 %then %do;
31243     +        tempFreeze
31244     +      %end;
31245     +     ;
31246     +   run;
31247     +   quit;
31249     +%mend;
31251     +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
31253     +/* initialize new quantile_binning macro */
31254     +filename temp catalog 'sashelp.emapps.quantile_binning.source';
31255     +%include temp;
31256     +filename temp;
31258     +/* generate fileref for quantile_binning macro */
31259     +filename X "&binningCode";
31261     +/* determine if there are inputs to be binned */
31262     +%let numbinvars = 0;
31263     +%let intdsid = %sysfunc(open(work._intmid));
31264     +%if &intdsid %then %do;
31265     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
31266     +%end;
31267     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
31268     +%if &numbinvars > 0 %then %do;
31270     +/* get data in format needed for quantile_binning macro */
31271     +data work.vartable;
31272     +  set work._intmid;
31273     +  level = "INTERVAL";
31274     +  role  = "INPUT";
31275     +  rename variable=name;
31276     +run;
31278     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
31279     +%if %EM_FREQ ne %then %do;
31280     +   data work.freq;
31281     +     name="%EM_FREQ";
31282     +     role="FREQ";
31283     +   run;
31285     +   data work.vartable;
31286     +     set work.vartable work.freq;
31287     +   run;
31288     +%end;
31291     +/* perform quantile binning of data */
31292     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
31293     +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
31295     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
31296     +%end;
31297     +%else %do;
31298     +  /* initialize binmappings table */
31299     +  data &EM_USER_BINMAPPINGS;
31300     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
31301     +  run;
31303     +  data _null_;
31304     +    FILE X;
31306     +    put "&EM_CODEBAR;";
31307     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
31308     +    put "* &note;";
31309     +    put "&EM_CODEBAR;";
31310     +  run;
31312     +%end;
31314     +/* assign display_var values to binmappings table as well as initial group values */
31315     +data &EM_USER_BINMAPPINGS;
31316     +  set &EM_USER_BINMAPPINGS;
31317     +  length display_var $32 grp $8;
31318     +  display_var = name;
31320     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31321     +    GRP = BIN + 1;
31322     +  %end;
31323     +  %else %do;
31324     +    GRP = BIN;
31325     +  %end;
31326     +run;
31328     +/* de-assign fileref */
31329     +filename X;
31331     +    /* append to binning code those values that were included in the importSubset data */
31332     +    %if &useImport eq 1 %then %do;
31333     +      %EM_IMPORT_BINNING(&binningcode);
31334     +    %end;
31336     +    /* append to binning code those values that were included in the freezeSubset data */
31337     +    %if &useFreeze eq 1 %then %do;
31338     +      %EM_FREEZE_BINNING(&binningcode);
31339     +    %end;
31341     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
31342     +      by NAME;
31343     +    run;
31345     +    /* create grouping for missing level */
31346     +    data tempmissvalues;
31347     +    run;
31349     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31350     +       data tempmissvalues;
31351     +         %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
31352     +           merge sortedmapping
31353     +           %if &useImport eq 1 %then %do;
31354     +              &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
31355     +           %end;
31356     +           %if &useFreeze eq 1 %then %do;
31357     +             &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
31358     +           %end;
31359     +           ;
31360     +         %end;
31361     +         %else %do;
31362     +           set sortedmapping;
31363     +         %end;
31364     +         GRP="1";
31365     +         bin="Missing";
31366     +         _split_value_ = "Missing";
31367     +         %if &useImport eq 1 %then %do;
31368     +            if _a then delete;
31369     +         %end;
31370     +         %if &useFreeze eq 1 %then %do;
31371     +            if _b then delete;
31372     +         %end;
31374     +       run;
31375     +    %end;
31378     +    /* create binData from binningCode */
31379     +    filename X "&binningCode";
31381     +    data &bindata;
31382     +      set &input;
31383     +      %inc X;
31384     +    run;
31386     +    filename X;
31388     +    /* create splitvals dataset */
31389     +    data tempsplitvals;
31390     +      set &EM_USER_BINMAPPINGS tempmissvalues;
31391     +      length newgroup _group_ _order_ 8 _level_ $8;
31392     +      newgroup =.;
31393     +      _LEVEL_ = 'ORDINAL';
31394     +      _Group_ = grp;
31395     +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
31396     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
31397     +    run;
31399     +    data tempsplitvals;
31400     +      set tempsplitvals;
31401     +      _order_ = _N_;
31402     +    run;
31404     +    /* determine if EM_USER_SPLITVALS already exists */
31405     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
31406     +    %if &sdsid > 0 %then %do;
31407     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
31408     +      %if &nvars > 0 %then %do;
31409     +        proc sql;
31410     +          reset noprint;
31411     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
31412     +        quit;
31413     +      %end;
31414     +      %else %let nobs=0;
31415     +    %end;
31416     +    %else %do;
31417     +       %let nobs=0;
31418     +       %let nvars=0;
31419     +    %end;
31420     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
31422     +    /* if useIMport=1 also include import definitions here as well */
31423     +    %if &useImport eq 1 %then %do;
31424     +      data tempImport;
31425     +        set &EM_USER_IMPORTSUBSET;
31426     +        _variable_ = binVar;
31427     +      run;
31428     +    %end;
31430     +    /* if useFreeze=1 also include frozen definitions here as well */
31431     +    %if &useFreeze eq 1 %then %do;
31432     +      data tempFreeze;
31433     +        length display_var $32;
31434     +        set &EM_USER_FreezeSUBSET;
31435     +        display_var = _variable_;
31436     +        _variable_ = binVar;
31437     +      run;
31438     +    %end;
31440     +    data &EM_USER_SPLITVALS;
31441     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
31442     +        set &EM_USER_SPLITVALS tempsplitvals
31443     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
31444     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
31445     +        %end;
31446     +        %if &useFreeze eq 1 %then %do;
31447     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
31448     +        %end;
31449     +        ;
31450     +      %end;
31451     +      %else %do;
31452     +        set tempsplitvals
31453     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
31454     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
31455     +        %end;
31456     +        %if &useFreeze eq 1 %then %do;
31457     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
31458     +        %end;
31459     +        ;
31460     +      %end;
31461     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
31462     +    run;
31464     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
31465     +    data tempvariableset;
31466     +      set &EM_DATA_VARIABLESET;
31467     +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
31468     +    run;
31470     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
31472     +    /* add all interval vars that aren't special codes to the intervalvar macro
31473     +    %let dsid = %sysfunc(open(work.tempvariableset));
31474     +    %if &dsid %then %do;
31475     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31476     +      %let obs = %sysfunc(fetch(&dsid));
31477     +      %do %while(&obs=0);
31478     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
31479     +        %let classvars = &classvars &varname;
31480     +        %let qclassvars = &qclassvars "&varname";
31481     +        %let obs = %sysfunc(fetch(&dsid));
31482     +      %end;
31483     +    %end;
31484     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31485     +*/
31486     +    %if %classvars ne %then %do;
31487     +      proc dmdb data =&bindata classout=_classout nonorm;
31488     +        class %classvars;
31489     +      run;
31491     +      proc dmdb data=&bindata classout=_classout2;
31492     +       class %classvars;
31493     +      run;
31495     +      proc sort data=_classout; by NAME CRAW; run;
31496     +      proc sort data=_classout2; by NAME CRAW; run;
31498     +      data _classout;
31499     +        length _variable_ $32;
31500     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
31501     +        by NAME CRAW;
31502     +       _variable_ = NAME;
31503     +      run;
31505     +      proc sort data=_classout; by _variable_ _split_value_; run;
31506     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
31508     +      data &EM_USER_SPLITVALS;
31509     +        length _norm_level_ $200 _split_value_ $200;
31510     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
31511     +        by _variable_ _split_value_;
31512     +        LEVEL = trim(left(LEVEL));
31513     +        _split_value_ = trim(left(_split_value_));
31514     +        _norm_level_ = trim(left(_norm_level_));
31515     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
31516     +        drop NAME FREQUENCY TYPE CRAW NRAW;
31517     +      run;
31519     +      proc datasets library=work nolist;
31520     +        delete _classout _classout2;
31521     +      run;
31522     +      quit;
31523     +    %end;
31525     +    data &EM_USER_SPLITVALS;
31526     +      set &EM_USER_SPLITVALS;
31527     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
31528     +    run;
31531     +    proc sort data=&EM_USER_SPLITVALS;
31532     +      by DISPLAY_VAR _Group_;
31533     +    run;
31535     +    proc datasets library=work nolist;
31536     +      delete sortedmapping tempsplitvals tempmissvalues
31537     +      %if &useImport eq 1 %then %do;
31538     +        tempImport
31539     +      %end;
31540     +      %if &useFreeze eq 1 %then %do;
31541     +        tempFreeze
31542     +      %end;
31543     +      ;
31544     +    run;
31545     +    quit;
31546     +/*
31547     +%end;
31548     +%else %do;
31549     +    data &bindata;
31550     +      set &input;
31551     +    run;
31552     +%end;
31553     +*/
31554     +%mend EM_QUANTILE_BINNING;
31556     +%macro EM_ORDVARS_GROUP;
31558     +   /* retrieve all ordinal variables from the incoming dataset */
31559     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
31560     +     by NAME;
31561     +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
31562     +   run;
31564     +   /* add all vars marked as interval that are actually class vars to this data */
31565     +   %let nobs = 0;
31566     +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
31567     +   %if &dsid %then %do;
31568     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31569     +     %if &nobs gt 0 %then %do;
31571     +     data tempvars;
31572     +       set &EM_DATA_VARIABLESET;
31573     +       if NAME in (
31574     +         %let obs = %sysfunc(fetch(&dsid));
31575     +         %do %while(&obs=0);
31576     +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
31577     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
31578     +           "&varname"
31579     +           %let obs = %sysfunc(fetch(&dsid));
31580     +         %end;
31581     +        );
31582     +     run;
31583     +     data tempvariableset;
31584     +       set tempvariableset tempvars;
31585     +     run;
31586     +     %end;
31587     +   %end;
31588     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31590     +   %if &useImport eq 1 %then %do;
31591     +     /* remove all variables from tempvariableset that are included in the importsubset */
31592     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
31593     +       by _VARIABLE_ ;
31594     +     run;
31595     +     proc sort data=tempvariableset; by NAME; run;
31597     +     data tempvariableset;
31598     +       merge tempimport(in=_a) tempvariableset(in=_b);
31599     +       by NAME;
31600     +       if ^_a then output;
31601     +     run;
31602     +   %end;
31604     +   %if &useFreeze eq 1 %then %do;
31605     +     /* remove all variables from tempvariableset that are included in the freezesubset */
31606     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
31607     +       by _VARIABLE_ ;
31608     +     run;
31609     +     proc sort data=tempvariableset; by NAME; run;
31611     +     data tempvariableset;
31612     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
31613     +       by NAME;
31614     +       if ^_a then output;
31615     +     run;
31616     +   %end;
31618     +   /* get dataset of distinct values for the ordinal variable */
31619     +   %let nobs = 0;
31620     +   %let dsid = %sysfunc(open(WORK.tempvariableset));
31621     +   %if &dsid %then %do;
31622     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31623     +     %if &nobs gt 0 %then %do;
31624     +         %let obs = %sysfunc(fetch(&dsid));
31625     +         %do %while(&obs=0);
31626     +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31627     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
31628     +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
31629     +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
31630     +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
31631     +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
31632     +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
31633     +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
31634     +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
31636     +           data temp;
31637     +             set &EM_USER_BINDATA(keep=&varname);
31638     +             %if &input_fmt ne %then %do;
31639     +               %dmnormcp(put(&varname, &input_fmt), _norm);
31640     +             %end;
31641     +             %else %do;
31642     +               %dmnormcp(&varname, _norm);
31643     +             %end;
31644     +             keep &varname _norm;
31645     +           run;
31647     +          proc dmdb data=temp classout=_classout2;
31648     +           class _norm;
31649     +         run;
31650     +         proc sort data=_classout2; by LEVEL; run;
31652     +         /* re-order numeric inputs based on non-normalized values */
31653     +         %if &input_type eq N %then %do;
31654     +           proc sort data=temp nodupkey; by _norm; run;
31655     +           data varvals;
31656     +             merge temp _classout2(rename=(LEVEL=_norm));
31657     +             by _norm;
31658     +             if craw='' and _norm ne '.' then delete;
31659     +             keep &varname _norm nraw craw;
31660     +           run;
31662     +           proc sort data=varvals; by &varname; run;
31663     +         %end;
31664     +         %else %do;
31665     +           data varvals;
31666     +              set _classout2(rename=(LEVEL=_norm));
31667     +              if _norm='' then delete;
31668     +              if _norm='.' then delete;
31669     +              keep _norm;
31670     +           run;
31671     +         %end;
31672     +         data varvals;
31673     +           set varvals;
31674     +           if &varname="." then delete;
31675     +           if upcase(&varname) = "MISSING" then delete;
31676     +         run;
31678     +          /* generate Splitvals Data */
31679     +          data tempsplitvals;
31680     +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ _order_ 8 _level_ $8 _norm_level_ $200 ;
31682     +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31683     +              DISPLAY_VAR="&varname";
31684     +              _VARIABLE_ ="&varname";
31685     +              newgroup   =.;
31686     +              _group_    =1;
31687     +              _Split_Value_="Missing";
31688     +              _level_    ="ORDINAL";
31689     +              output;
31690     +              %let group=2;
31691     +            %end;
31692     +            %else %let group=1;
31694     +            %let vdsid = %sysfunc(open(WORK.VARVALS));
31695     +            %if &vdsid %then %do;
31696     +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
31697     +            /*%let group = 2;*/
31698     +            %let vobs = %sysfunc(fetch(&vdsid));
31699     +            %do %while(&vobs=0);
31700     +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))));
31702     +                DISPLAY_VAR   = "&varname";
31703     +                _variable_    = "&varname";
31704     +                newgroup      = .;
31705     +                _group_       = &group;
31706     +                _split_value_ = "&nameval";
31707     +                _level_       = 'ORDINAL';
31708     +                output;
31710     +              %let group = %eval(&group + 1);
31711     +              %let vobs = %sysfunc(fetch(&vdsid));
31712     +            %end;
31713     +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
31714     +          run;
31716     +          /* determine if EM_USER_SPLITVALS already exists */
31717     +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
31718     +          %if &sdsid > 0 %then %do;
31719     +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
31720     +            %if &nvars > 0 %then %do;
31721     +               proc sql;
31722     +                reset noprint;
31723     +                select count(*) into :nobs from &EM_USER_SPLITVALS;
31724     +               quit;
31725     +            %end;
31726     +            %else %let nobs=0;
31727     +            %end;
31728     +            %else %do;
31729     +              %let nobs=0;
31730     +              %let nvars=0;
31731     +            %end;
31732     +          %end;
31733     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
31735     +          /* if tempsplitvals doesn't exist; create empty data set */
31736     +          %let sdsid = %sysfunc(open(work.tempsplitvals));
31737     +          %if &sdsid <= 0 %then %do;
31738     +            data tempsplitvals;
31739     +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ 8 _level_ $8 ;
31740     +            run;
31741     +          %end;
31742     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
31744     +          data tempsplitvals;
31745     +            set tempsplitvals;
31746     +            _order_ = _N_;
31747     +          run;
31749     +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
31750     +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
31751     +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
31752     +          %end;
31754     +          data &EM_USER_SPLITVALS;
31755     +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
31756     +             merge &EM_USER_SPLITVALS tempsplitvals;
31757     +             by _variable_ _split_value_;
31758     +           %end;
31759     +           %else %do;
31760     +             set tempsplitvals;
31761     +           %end;
31762     +           if display_var eq "" then delete;
31763     +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
31764     +           keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_ _order_;
31765     +         run;
31767     +           %let obs = %sysfunc(fetch(&dsid));
31768     +         %end;
31769     +     %end;
31770     +   %end;
31771     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31773     +   proc sort data=&EM_USER_SPLITVALS;
31774     +      by DISPLAY_VAR _Group_;
31775     +   run;
31777     +   /* delete temporary datasets */
31778     +   proc datasets library= work nolist;
31779     +     delete tempsplitvals varvals tempvariableset tempvars
31780     +     ;
31781     +   run;
31782     +   quit;
31783     +%mend EM_ORDVARS_GROUP;
31786     +%macro EM_CLASSVARS_GROUP(groupRare);
31788     +   /* retrieve all class variables from the incoming dataset */
31789     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
31790     +     by NAME;
31791     +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
31792     +   run;
31794     +   %if &useImport eq 1 %then %do;
31795     +     /* remove all variables from tempvariableset that are included in the importsubset */
31796     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
31797     +       by _VARIABLE_ ;
31798     +     run;
31799     +     proc sort data=tempvariableset; by NAME; run;
31801     +     data tempvariableset;
31802     +       merge tempimport(in=_a) tempvariableset(in=_b);
31803     +       by NAME;
31804     +       if ^_a then output;
31805     +     run;
31806     +   %end;
31808     +   %if &useFreeze eq 1 %then %do;
31809     +     /* remove all variables from tempvariableset that are included in the freezesubset */
31810     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
31811     +       by _VARIABLE_ ;
31812     +     run;
31813     +     proc sort data=tempvariableset; by NAME; run;
31815     +     data tempvariableset;
31816     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
31817     +       by NAME;
31818     +       if ^_a then output;
31819     +     run;
31820     +   %end;
31822     +   /* run dmdb to retrieve list of all class levels and counts */
31823     +   %let dsid = %sysfunc(open(work.tempvariableset));
31824     +   %let nobs = 0;
31825     +   %if &dsid %then %do;
31826     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31828     +   %end;
31830     +   %if &nobs gt 0 %then %do;
31831     +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
31832     +       class
31834     +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
31835     +        %let obs = %sysfunc(fetch(&dsid));
31836     +        %do %while(&obs=0);
31837     +           %let name = %sysfunc(getvarc(&dsid, &namenum));
31838     +           &name
31839     +           %let obs = %sysfunc(fetch(&dsid));
31840     +        %end;
31841     +     ;
31843     +     %if %EM_FREQ ne %then %do;
31844     +        freq %EM_FREQ;
31845     +     %end;
31846     +    run;
31847     +   %end;
31848     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31850     +   %let dsid = %sysfunc(open(work.tempclassout));
31851     +   %let nobs = 0;
31852     +   %if &dsid %then %do;
31853     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31854     +     %let dsid = %sysfunc(close(&dsid));
31855     +   %end;
31857     +   %if &nobs gt 0 %then %do;
31858     +    data tempclassout;
31859     +       set tempclassout;
31860     +       if LEVEL='MISSING' then level='Missing';
31861     +    run;
31863     +    proc sort data=tempclassout nodupkey;
31864     +      by NAME descending FREQUENCY LEVEL;
31865     +    run;
31867     +    data tempds(keep=NAME NOBS);
31868     +      retain NOBS;
31869     +      set tempclassout;
31870     +      by NAME;
31871     +      if first.NAME then
31872     +        NOBS = frequency;
31873     +      else
31874     +        NOBS=NOBS+frequency;
31875     +      if last.name then do;
31876     +        output;
31877     +      end;
31878     +    run;
31880     +    data tempds;
31881     +      merge tempclassout
31882     +      tempds;
31883     +      by NAME;
31884     +      if ((LEVEL ne '') AND (LEVEL ne "."));
31885     +      %if &groupRare eq Y %then %do;
31886     +        PCT = 100 * (FREQUENCY/NOBS);
31887     +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
31888     +        else flag=0;
31889     +      %end;
31890     +      %else %do;
31891     +        flag = 0;
31892     +      %end;
31893     +    run;
31895     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31896     +      data tempmissvalues;
31897     +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
31899     +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
31900     +      %if &dsid %then %do;
31901     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31902     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
31903     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
31904     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
31905     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
31906     +        %let obs = %sysfunc(fetch(&dsid));
31908     +        %do %while(&obs=0);
31909     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
31910     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
31911     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
31912     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
31914     +          NAME="&var";
31915     +          LEVEL="Missing";
31916     +          _LEVEL_="&varlvl";
31917     +          _group_ = 1;
31918     +          output;
31920     +          %let obs = %sysfunc(fetch(&dsid));
31921     +        %end;
31922     +      %end;
31923     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31924     +      run;
31925     +    %end;
31927     +    /* generate Splitvals Data */
31928     +    data tempsplitvals;
31929     +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
31931     +      set tempclassout
31932     +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31933     +         tempmissvalues
31934     +      %end;
31935     +      ;
31936     +      if ((level ne '') AND (level ne '.'));
31938     +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
31939     +     %if &dsid %then %do;
31940     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31941     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
31942     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
31943     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
31944     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
31945     +        %let obs = %sysfunc(fetch(&dsid));
31947     +        %do %while(&obs=0);
31948     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
31949     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
31950     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
31951     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
31953     +          if NAME = "&var" then do;
31954     +            _LEVEL_ = "&varlvl";
31956     +          /* cycle through levels, assigning group values;              */
31957     +          /* flag=1 indicates to put value in "_OTHER_" group;          */
31958     +          /* flag=0 indicates that value shoudld be in group of its own */
31959     +          %let choice = ((NAME="&Var") and (FLAG=0));
31960     +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31961     +            %let group=2;
31962     +          %end;
31963     +          %else %do;
31964     +            %let group = 1;
31965     +          %end;
31966     +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
31967     +          %if &fdsid %then %do;
31969     +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
31970     +            %let fobs = %sysfunc(fetch(&Fdsid));
31971     +            %let fflag = 0;
31972     +            %do %while(&fobs=0);
31973     +              %let fflag = 1;
31974     +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
31975     +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
31976     +              %let level = %nrbquote(%sysfunc(strip(&level)));
31977     +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
31978     +                %if &group eq 2 %then %do;
31979     +                   if LEVEL = "&level" then _GROUP_ = &group;
31980     +                %end;
31981     +                %else %do;
31982     +                   else if LEVEL = "&level" then _GROUP_ = &group;
31983     +                %end;
31984     +              %end;
31985     +              %else %do;
31986     +                %if &group eq 1 %then %do;
31987     +                   if LEVEL = "&level" then _GROUP_ = &group;
31988     +                %end;
31989     +                %else %do;
31990     +                   else if LEVEL = "&level" then _GROUP_ = &group;
31991     +                %end;
31992     +              %end;
31994     +              %let group = %eval(&group + 1);
31995     +              %let fobs = %sysfunc(fetch(&fdsid));
31996     +            %end;
31998     +          %end;
31999     +          %if &fflag eq 1 %then %do;
32000     +            else if LEVEL ^='Missing' then _GROUP_ = &group;
32001     +          %end;
32002     +          end;
32004     +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
32005     +          %let obs = %sysfunc(fetch(&dsid));
32006     +        %end;
32007     +     %end;
32008     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32009     +     _VARIABLE_ = NAME;
32010     +     newgroup = .;
32011     +     rename NAME = DISPLAY_VAR
32012     +            LEVEL = _SPLIT_VALUE_;
32013     +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
32014     +    run;
32015     +  %end;
32016     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32018     +    /* determine if EM_USER_SPLITVALS already exists */
32019     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
32020     +    %if &sdsid > 0 %then %do;
32021     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
32022     +      %if &nvars > 0 %then %do;
32023     +        proc sql;
32024     +          reset noprint;
32025     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
32026     +        quit;
32027     +      %end;
32028     +      %else %let nobs=0;
32029     +    %end;
32030     +    %else %do;
32031     +       %let nobs=0;
32032     +       %let nvars=0;
32033     +    %end;
32034     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
32036     +   /* if tempsplitvals doesn't exist; create empty data set */
32037     +    %let sdsid = %sysfunc(open(work.tempsplitvals));
32038     +    %if &sdsid <= 0 %then %do;
32039     +      data tempsplitvals;
32040     +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
32041     +      run;
32042     +    %end;
32043     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
32045     +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
32046     +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
32047     +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
32048     +    %end;
32050     +    /* if useIMport=1 also include import definitions here as well */
32051     +    %if &useImport eq 1 %then %do;
32052     +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
32053     +    %end;
32054     +    %if &useFreeze eq 1 %then %do;
32055     +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
32056     +    %end;
32057     +    data &EM_USER_SPLITVALS;
32058     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
32059     +        merge &EM_USER_SPLITVALS tempsplitvals
32060     +        %if &useImport eq 1 %then %do;
32061     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
32062     +        %end;
32063     +        %if &useFreeze eq 1 %then %do;
32064     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
32065     +        %end;
32067     +        ;
32068     +        by _variable_ _split_value_
32069     +        ;
32070     +      %end;
32071     +      %else %do;
32072     +        set tempsplitvals
32073     +        %if &useImport eq 1 %then %do;
32074     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
32075     +        %end;
32076     +        %if &useFreeze eq 1 %then %do;
32077     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
32078     +        %end;
32079     +        ;
32080     +      %end;
32081     +      if display_var eq "" then delete;
32082     +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
32083     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
32084     +    run;
32086     +    proc sort data=&EM_USER_SPLITVALS;
32087     +      by DISPLAY_VAR _Group_;
32088     +    run;
32090     +   /* delete temporary datasets */
32091     +   proc datasets library= work nolist;
32092     +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
32093     +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
32094     +       tempmissvalues
32095     +     %end;
32096     +     ;
32097     +   run;
32098     +   quit;
32099     +%mend EM_CLASSVARS_GROUP;
32102     +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
32104     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
32106     +  data temptrain ;
32107     +    set &data;
32108     +  run;
32110     +  /* normalize all values prior to calculating counts */
32111     +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
32112     +  %include _temp;
32113     +  filename _temp;
32114     +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
32115     +  %include _temp;
32116     +  filename _temp;
32118     +  proc sort data=&EM_USER_VARMAPPINGS
32119     +  %if &varname ne %then %do;
32120     +    (where=(_variable_="&varname"))
32121     +  %end;
32122     +  out=tempmap; by _variable_; run;
32124     +  data _cmeta;
32125     +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
32126     +    by name;
32127     +    if ((_a) or (role="TARGET"));
32128     +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
32129     +    %if %length(%EM_BINARY_TARGET) %then %do;
32130     +      if role="TARGET" then role="INPUT";
32131     +    %end;
32132     +    level = procLevel;
32133     +    index = kindex(name, "BIN_");
32134     +    if index gt 0 then do;
32135     +     level="ORDINAL";
32136     +     format = "";
32137     +    end;
32138     +    drop index;
32139     +  run;
32141     +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
32142     +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N, outdata=_tmp_train);
32144     +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
32146     +  data _null_;
32147     +    set sortedmap end=eof;
32148     +    by _proc_var_;
32149     +    if _n_=1 then do;
32150     +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
32151     +      call execute("ods listing close;");
32152     +      call execute("proc freq data=_tmp_train order=formatted addnames;");
32153     +      call execute("tables ("||_proc_var_);
32154     +    end;
32155     +    else do;
32156     +      call execute(_proc_var_);
32157     +    end;
32158     +    if eof then do;
32159     +      call execute(") * &ignbintarget/ missing;");
32160     +      %if %EM_FREQ ne %then %do;
32161     +        call execute("weight %EM_FREQ;");
32162     +      %end;
32163     +      call execute("run;");
32164     +      call execute("ods output close;");
32165     +      call execute("ods listing;");
32166     +    end;
32167     +  run;
32169     +  data _null_;
32170     +    set sortedmap end=eof;
32171     +    by _proc_var_;
32172     +    if _n_=1 then do;
32173     +      call execute("data crosstabs;");
32174     +      call execute("  length _variable_ _split_value_  $200 ;");
32175     +      call execute("  set crosstabfreq(where=(_type_='11'));");
32176     +      call execute("  _variable_= RowVariable;");
32177     +    end;
32179     +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
32180     +    call execute("  _split_value_="||_proc_var_||";");
32181     +    call execute("end;");
32183     +    if eof then do;
32184     +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent display_var;");
32185     +      call execute("run;");
32186     +    end;
32187     +  run;
32189     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
32191     +  data crosstabs;
32192     +    length display_var $32;
32193     +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
32194     +    by _variable_;
32195     +  run;
32197     +  proc sort data=crosstabs; by display_var _split_value_; run;
32198     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
32200     +  data crosstabs;
32201     +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
32202     +    by display_var;
32203     +    index = kindex(_variable_, "BIN_");
32204     +    if index gt 0 then do;
32205     +     level="ORDINAL";
32206     +     format = "";
32207     +    end;
32208     +    _temp = &ignbintarget;
32209     +    /*
32210     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
32211     +      %if &target_format ne %then %do;
32212     +        %if &target_type eq C %then %do;
32213     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
32214     +        %end;
32215     +        %else %do;
32216     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
32217     +        %end;
32218     +      %end;
32219     +      %else %do;
32220     +        %dmnormcp(&ignbintarget, _temp);
32221     +      %end;
32222     +    %end;
32223     +    %else %do;
32224     +      _temp = &ignbintarget;
32225     +    %end;
32226     +*/
32228     +    drop index;
32229     +  run;
32231     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
32233     +  data &outdata;
32234     +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate  8 type $1 valfmt $20 ;
32236     +    retain eventCount noneventCount ;
32237     +    set crosstabs;
32238     +    by  _variable_ _split_value_;
32240     +    if first._split_value_ then do;
32241     +     total=0;
32242     +     eventcount=0;
32243     +     noneventcount=0;
32244     +    end;
32246     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
32247     +      %if &target_format ne %then %do;
32248     +        if upcase(strip(_temp))="&target_event" then
32249     +          eventCount=Frequency;
32250     +      %end;
32251     +      %else %do;
32252     +         if upcase(strip(_temp)) ="&target_event" then
32253     +          eventCount=Frequency;
32254     +      %end;
32255     +    %end;
32256     +    %else %do;
32257     +      if _temp=&target_event then
32258     +        eventCount=Frequency;
32259     +    %end;
32260     +    else
32261     +      noneventCount=Frequency;
32263     +    if last._split_value_ then do;
32264     +      total = eventCount + noneventCount;
32266     +      if total ne 0 then do;
32267     +        eventRate = eventCount / total;
32268     +        nonEventRate = nonEventCount / total;
32269     +      end;
32270     +      else do;
32271     +        eventRate = 0;
32272     +        nonEventRate = 0;
32273     +      end;
32274     +     output;
32275     +    end;
32276     +    valfmt = format;
32278     +    drop _temp Frequency percent;
32279     +   run;
32281     +%mend EM_SUMMARIZE_TABLE;
32284     +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings, interactiveFlag=0);
32286     +   proc freq data=&bindata noprint;
32287     +     table &ignbintarget / missing out=temptargetB;
32288     +     %if %EM_FREQ ne %then %do;
32289     +       weight %EM_FREQ;
32290     +     %end;
32291     +   run;
32293     +   %let tdsid = %sysfunc(open(work.temptargetB));
32294     +   %if &tdsid %then %do;
32295     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
32296     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
32298     +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
32299     +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32300     +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
32301     +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32304     +      %let obs = %sysfunc(fetch(&tdsid));
32305     +      %do %while(&obs = 0);
32306     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
32307     +           %if &target_type eq C %then %do;
32308     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
32309     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32310     +           %end;
32311     +           %else
32312     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
32314     +           %if &target_format ne %then %do;
32315     +              %if &target_type eq C %then %do;
32316     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
32317     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32318     +              %end;
32319     +              %else
32320     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
32321     +           %end;
32322     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
32323     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
32325     +           %if "&tarvalue" eq "&target_event" %then %do;
32326     +             %let totalevent = &count;
32327     +           %end;
32328     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
32329     +              %let totalnonevent= &count;
32330     +           %end;
32331     +         %end;
32332     +         %else %do;
32333     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
32334     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
32336     +           %if &tarvalue eq &target_event %then %do;
32337     +             %let totalevent = &count;
32338     +           %end;
32339     +           %else %if &tarvalue eq &target_nonevent %then %do;
32340     +              %let totalnonevent= &count;
32341     +           %end;
32342     +         %end;
32343     +         %let obs = %sysfunc(fetch(&tdsid));
32344     +      %end;
32345     +   %end;
32346     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
32348     +   proc datasets lib=work nolist;
32349     +      delete temptargetB;
32350     +   run;
32351     +   quit;
32353     +   %if &interactiveFlag eq 0 %then %do;
32354     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
32355     +   %end;
32356     +   %else %do;
32357     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar);
32358     +   %end;
32361     +   data &fineDetailData;
32362     +     length display_var $32 newgroup numsplitval 8;
32363     +     set &fineDetailData;
32365     +     display_var = _variable_;
32367     +     index = kindex(display_var, "BIN_");
32368     +     if index gt 0 then do;
32369     +       display_var = ksubstr(display_var, 5);
32370     +     end;
32372     +     index2 = kindex(display_var, "SV_");
32373     +     if index2 gt 0 then do;
32374     +       display_var = ksubstr(display_var, 4);
32375     +     end;
32377     +     /* re-code missing values to "Missing" */
32378     +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
32379     +     _index_ = _N_;
32380     +     newgroup = .;
32381     +     drop index index2 ;
32382     +   run;
32384     +   /* add group information to fineDetailData; */
32385     +   /* add label information for binned variables to fineDetailData*/
32387     +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
32389     +   data tmpsplitvals;
32390     +     set &splitvals;
32391     +     _norm_level_ = upcase(_norm_level_);
32392     +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
32393     +    * drop _split_value_;
32394     +   run;
32396     +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
32397     +   proc datasets library=work nolist;
32398     +     delete tmpsplitvals;
32399     +   run;
32400     +   quit;
32402     +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
32404     +   data &fineDetailData;
32405     +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
32406     +      by _variable_ _split_value_;
32407     +      if _a then do;
32408     +        binFlag = 1;
32409     +        VALUE=EM_BIN_LABEL;
32410     +      end;
32411     +      else do;
32412     +        binFlag = 0;
32413     +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
32414     +        VALUE=strip(_split_value_);
32416     +      end;
32418     +      if ((eventCount=.) or (nonEventCount=.)) then do;
32419     +        eventCount=0;
32420     +        nonEventCount=0;
32421     +        total = 0;
32422     +        eventRate= 0;
32423     +        nonEventRate = 0;
32424     +      end;
32426     +      eventCount = round(eventCount, .001);
32427     +      nonEventCount = round(nonEventCount, .001);
32428     +      total= round(total, .001);
32429     +      eventRate = round(eventRate, .001);
32430     +      nonEventRate = round(nonEventRate, .001);
32432     +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
32433     +         numsplitval = _split_value_;
32434     +     else if ((type='N') AND (valfmt ne "")) then
32435     +        numsplitval = _order_;
32436     +     else numsplitval=.;
32438     +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
32439     +      if _a and ^_b then delete;
32440     +      if _c and ^_b then delete;
32441     +      drop NAME EM_BIN_LABEL valfmt;
32442     +   run;
32444     +   /* for class variables that have values falling into the "other" category, set _LEVEL_ and _GROUP_ based on Missing level */
32445     +   data &fineDetailData;
32446     +     set &fineDetailData;
32448     +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
32449     +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
32450     +     %if &dsid %then %do;
32451     +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
32452     +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
32453     +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
32455     +       %let obs = %sysfunc(fetch(&dsid));
32456     +       %do %while(&obs=0);
32457     +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
32458     +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
32459     +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
32461     +         if DISPLAY_VAR = "&dispvar" then do;
32462     +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
32463     +           if _GROUP_ = . then _GROUP_ = &group;
32464     +         end;
32466     +         %let obs = %sysfunc(fetch(&dsid));
32467     +       %end;
32468     +     %end;
32469     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32470     +     if _GROUP_ = . then delete;
32471     +    * if binFlag=1 and UB=LB then delete;
32472     +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
32473     +   run;
32475     +   proc sort data=&fineDetailData;
32476     +     by DISPLAY_VAR _index_;
32477     +   run;
32479     +   proc datasets lib=work nolist;
32480     +     delete sortedsplit sortedbin
32481     +     ;
32482     +   run;
32483     +   quit;
32484     +%mend EM_FINE_DETAIL;
32486     +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
32488     +   proc freq data=&bindata noprint;
32489     +     table &ignbintarget / missing out=temptargetC;
32490     +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
32491     +     %end;
32492     +   run;
32494     +   %let tdsid = %sysfunc(open(work.temptargetC));
32495     +   %if &tdsid %then %do;
32496     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
32497     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
32499     +      %let obs = %sysfunc(fetch(&tdsid));
32500     +      %do %while(&obs = 0);
32501     +        /* %if &target_type eq C or &target_format ne %then %do; */
32502     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
32503     +           %if &target_type eq C %then %do;
32504     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
32505     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32506     +           %end;
32507     +           %else
32508     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
32510     +           %if &target_format ne %then %do;
32511     +              %if &target_type eq C %then %do;
32512     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
32513     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
32514     +              %end;
32515     +              %else
32516     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
32517     +           %end;
32518     +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
32519     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
32521     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
32522     +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
32523     +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
32525     +           %if "&tarvalue" eq "&target_event" %then %do;
32526     +             %let totalevent = &count;
32527     +           %end;
32528     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
32529     +              %let totalnonevent= &count;
32530     +           %end;
32531     +         %end;
32532     +         %else %do;
32533     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
32534     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
32536     +           %if &tarvalue eq &target_event %then %do;
32537     +             %let totalevent = &count;
32538     +           %end;
32539     +           %else %if &tarvalue eq &target_nonevent %then %do;
32540     +              %let totalnonevent= &count;
32541     +           %end;
32542     +         %end;
32543     +         %let obs = %sysfunc(fetch(&tdsid));
32544     +      %end;
32545     +   %end;
32546     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
32548     +   proc datasets lib=work nolist;
32549     +      delete temptargetC;
32550     +   run;
32551     +   quit;
32553     +   proc means data=&FINEDETAILDATA noprint;
32554     +      var eventCount nonEventCount;
32555     +      class _variable_  _group_;
32556     +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
32557     +   run;
32559     +   proc sort data=summ(drop=_type_ _freq_);
32560     +     by _variable_ _group_;
32561     +   run;
32563     +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
32564     +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
32565     +        set summ;
32566     +        *format groupresprate 6.2;
32567     +        *format groupnonresprate 6.2;
32568     +        by _variable_ ;
32569     +        if _group_=. then do;
32570     +        end;
32571     +        else do;
32572     +           respper = eventCount / &totalEvent;
32573     +           nrespper = nonEventCount / &totalNonEvent;
32575     +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
32576     +                groupresprate=0;
32577     +                groupNonresprate = 0;
32578     +                eventRate = 0;
32579     +                nonEventRate = 0;
32580     +           end;
32581     +           else do;
32582     +               groupresprate = eventCount / (eventCount + nonEventCount) ;
32583     +               groupNonRespRate = 1 - groupRespRate;
32584     +               eventRate = eventCount / &totalEvent ;
32585     +               nonEventRate = nonEventCount / &totalNonEvent ;
32586     +            end;
32588     +           output gini tempcoarse;
32590     +        end;
32591     +   run;
32592     +   proc sort data=gini;
32593     +      by _variable_ descending groupresprate;
32594     +   run;
32596     +   data gini(keep= _variable_ _gini_);
32597     +     retain between within cumresp cumnresp;
32598     +     set gini(keep=_variable_  eventCount nonEventCount);
32599     +     by _variable_;
32600     +     if first._variable_ then do;
32601     +       between  = 0;
32602     +       within   = 0;
32603     +       cumresp  = 0;
32604     +       cumnresp = 0;
32605     +     end;
32606     +     between + 2 * cumnresp * eventCount;
32607     +     within + nonEventCount * eventCount;
32608     +     cumresp + eventCount;
32609     +     cumnresp + nonEventCount;
32610     +     if last._variable_ then do;
32611     +       if ^(cumnresp=0 or cumresp=0) then do;
32612     +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
32613     +         output;
32614     +       end;
32615     +     end;
32616     +   run;
32618     +   data tempdisplayvar;
32619     +      set &EM_USER_VARMAPPINGS;
32620     +      rename _variable_ = display_var
32621     +      _proc_var_ = _variable_;
32622     +   keep _variable_ _proc_var_ label;
32623     +   run;
32624     +   proc sort data=tempdisplayvar; by _variable_; run;
32626     +   data  &COARSE;
32627     +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
32628     +     merge tempdisplayvar tempcoarse gini ;
32629     +     by _variable_;
32630     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
32631     +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel , NOQUOTE))"
32632     +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel , NOQUOTE))"
32633     +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel , NOQUOTE))"
32634     +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel , NOQUOTE))"
32635     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  , NOQUOTE))"
32636     +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  , NOQUOTE))"
32637     +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel  , NOQUOTE))"
32638     +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel  , NOQUOTE))"
32639     +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupnonresprate_vlabel  , NOQUOTE))"
32640     +           ;
32642     +    eventCount = round(eventCount, .001);
32643     +    nonEventCount = round(nonEventCount, .001);
32644     +    groupRespRate = round(groupRespRate, .001);
32646     +     drop _variable_ index index2 respper nrespper;
32647     +   run;
32649     +   proc datasets library=work nolist;
32650     +     delete  tempcoarse gini             ;
32652     +   run;
32653     +   quit;
32655     +%mend EM_CREATE_GROUPING;
32659     +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
32661     +         data _null_;
32662     +            FILE &filename;
32663     +            put " length _LABEL_ $200;";
32664     +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
32665     +         run;
32667     +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var _split_Value_; run;
32668     +         proc sort data=&BINMAPPINGS; by display_var bin; run;
32670     +         data temp;
32671     +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
32672     +           by Display_Var _Split_value_;
32673     +           if upcase(_Split_value_) ne 'MISSING';
32674     +           if _a then output;
32675     +           if display_var eq '' then delete;
32676     +         run;
32678     +         data temp_missing;
32679     +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
32680     +           by Display_Var _Split_value_;
32681     +           if upcase(_Split_value_) eq 'MISSING';
32682     +           if _a then output;
32683     +           keep _variable_ display_var missgrp;
32684     +         run;
32686     +         proc sort data=temp out=class;
32687     +            by _variable_ _group_ LB;
32688     +         run;
32690     +         data _null_;
32692     +            file &filename MOD;
32693     +            length string $200 flag 8;
32694     +            retain string flag;
32695     +            set class end=eof;
32696     +            by _variable_  _group_;
32698     +            index = kindex(_variable_, "BIN_");
32699     +            if index gt 0 then do;
32700     +              if first._group_ then do;
32701     +                flag = 0;
32702     +                if ^first._variable_ then
32703     +                    put 'else';
32704     +                 else
32705     +                    put ' ';
32707     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
32708     +                          !!strip(put(_GROUP_,best12.))!!' then do;';
32709     +                 put string;
32711     +                 if LB ne . then do;
32712     +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
32713     +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
32714     +                 end;
32715     +                 else do;
32716     +                    flag = 1;
32717     +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
32718     +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
32719     +                 end;
32721     +              end;
32722     +              if last._Group_ then do;
32723     +                 if UB ne . then do;
32724     +                    string = strip(string)!!'< '!!strip(UB)!!"';";
32725     +                 end;
32726     +                 else do;
32727     +                    if flag=1 then do;
32728     +                      string = strip(string)!!"';";
32729     +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
32730     +                    end;
32731     +                    else do;
32732     +                      string = strip(string)!!"';";
32733     +                    end;
32734     +                 end;
32735     +                 put string;
32737     +                 string= " UB="!!strip(UB)!!";";
32738     +                 put string;
32739     +                 put "end;";
32742     +              end;
32743     +            end;
32744     +            else do;
32745     +              _split_value_ = tranwrd(_split_value_,"'","''");
32746     +              if first._group_ then do;
32747     +                 flag = 0;
32748     +                 if ^first._variable_ then
32749     +                    put 'else';
32750     +                 else
32751     +                    put ' ';
32752     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
32753     +                          !!strip(put(_GROUP_,best12.))!!' then';
32754     +                 put string;
32755     +                 string = "_LABEL_='"!!strip(_split_value_);
32756     +              end;
32757     +              else do;
32758     +                 if flag ne 1 then do;
32759     +                   tempstring = strip(string)!!', '!!strip(_split_value_);
32760     +                   length = length(tempstring);
32762     +                   if length < 195 then do;
32763     +                      string = tempstring;
32764     +                   end;
32765     +                   else do;
32766     +                      string = strip(string)||",...";
32767     +                      flag=1;
32768     +                   end;
32769     +                 end;
32770     +              end;
32772     +              if last._group_ then do;
32773     +                 string = strip(string)!!"';";
32774     +                 put string;
32775     +              end;
32776     +            end;
32777     +         run;
32779     +         data &COARSE;
32780     +           set &COARSE;
32781     +          /* %inc Y; */
32782     +           %inc &filename;
32783     +         run;
32784     +         *filename Y;
32786     +         /* add missing to appropriate label - based on temp_missing data */
32787     +         data &COARSE;
32788     +           set &COARSE;
32790     +           %let dsid = %sysfunc(open(work.temp_missing));
32791     +           %if &dsid %then %do;
32792     +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
32793     +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
32795     +              %let obs = %sysfunc(fetch(&dsid));
32796     +              %do %while(&obs=0);
32797     +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
32798     +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
32800     +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
32801     +                   if _LABEL_ eq '' then do;
32802     +                     _LABEL_ = "Missing";
32803     +                   end;
32804     +                   else do;
32805     +                     _LABEL_ = strip(_LABEL_)!!", Missing";
32806     +                   end;
32807     +                 end;
32808     +                 %let obs = %sysfunc(fetch(&dsid));
32809     +              %end;
32810     +           %end;
32811     +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32812     +           drop ub;
32813     +         run;
32815     +         proc datasets library=work nolist;
32816     +           delete class temp temp_missing;
32817     +         run;
32818     +         quit;
32820     +%mend EM_GENERATE_LABELVALUES;
32822     +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
32825     +%mend calcValidationCoarse;
32828     +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
32829     +/* macro for transforming interval target to binary */
32831     +   %if &method = CUTMEAN %then %do;
32832     +      proc sql noprint;
32833     +         %if %EM_FREQ ne %then %do;
32834     +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
32835     +         %end;
32836     +         %else %do;
32837     +            select mean(&inttgtvar)
32838     +         %end;
32839     +         into :ignbincut from &em_import_data;
32840     +      quit;
32841     +   %end;
32843     +   /* create binary target */
32844     +   data &EM_USER_NEWTRAIN;
32845     +      set &EM_IMPORT_DATA;
32846     +      %if &method = CUTUSER %then %do;
32847     +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
32848     +      %end;
32849     +      if &inttgtvar = . then &IGNBinTarget = .;
32850     +      else do;
32851     +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
32852     +         else &IGNBinTarget=0;
32853     +      end;
32854     +   run;
32856     +   /* Check that new target is actually binary */
32857     +   proc sql noprint;
32858     +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where &IGNBinTarget ne .;
32859     +   quit;
32860     +   %global &newlevels;
32861     +   %let &newlevels=&sqlobs;
32863     +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select mean(SalePrice) into :ignbincut from EMWS1.Trans_TRAIN;
NOTE: Variable _WARN_ is uninitialized.
NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.20 seconds
      cpu time            0.20 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.23 seconds
      cpu time            0.21 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   data EMWS1.BINNING_NEWTRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   set EMWS1.Trans_TRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice = . then BIN_SalePrice = .;
MPRINT(EM_IBN_INTTARGETTRANS):   else do;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice > 75017.56 then BIN_SalePrice=1;
MPRINT(EM_IBN_INTTARGETTRANS):   else BIN_SalePrice=0;
MPRINT(EM_IBN_INTTARGETTRANS):   end;
MPRINT(EM_IBN_INTTARGETTRANS):   run;

NOTE: Variable _WARN_ is uninitialized.
NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.25 seconds
      cpu time            0.23 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set EMWS1.BINNING_NEWTRAIN has 193 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.28 seconds
      cpu time            0.26 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select distinct BIN_SalePrice into :bintv1 - from EMWS1.BINNING_NEWTRAIN where BIN_SalePrice ne .;
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_FINEDETAILDATA;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_FINEDETAILDATA (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.10 seconds
      cpu time            0.11 seconds
      

MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS1.BINNING_VARMAPPINGS(keep=_variable_ _grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Input Variable" _grp_variable_ = "Group Variable";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_SPLITVALS;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_SPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.17 seconds
      cpu time            0.15 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 8 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 8 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=4,
      Created=Thu, Nov 12, 2015 01:26:29 PM,
      Last Modified=Thu, Nov 12, 2015 01:26:29 PM,
      Filename=C:\Users\sakerb01\AppData\Local\Temp\SAS Temporary Files\_TD2040_COB-IT-M10_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 6 records were written to the file MACFILE.
      The minimum record length was 9.
      The maximum record length was 68.
NOTE: There were 8 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
32868     +%macro intervalvars;
32869     +Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor
32870     +TotalArea
32871     +%mend intervalvars;
32872     +%global num_intvars;
32873     +%let num_intvars = 8 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS1.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor TotalArea
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 193   Memory used = 511K.
NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 32 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 32 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 4 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 4 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 32 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 32 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 32 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 8 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 8 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Level for Interactive";
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
32875     +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode, codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
32877     +  /* initialize binmappings table */
32878     +  data &BINMAPPINGS;
32879     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
32880     +  run;
32884     +  %if &IncludeTarget=N %then %do;
32885     +   /* process only INTERVAL INPUTS */
32886     +  data tempvars;
32887     +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
32888     +  run;
32889     +  %end;
32891     +  %if &IncludeTarget=Y %then %do;
32892     +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
32893     +  data tempvars;
32894     +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND LEVEL="INTERVAL")));
32895     +  run;
32896     +  %end;
32898     +  /* retrieve the name of interval inputs to bin */
32899     +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
32900     +  %include tempopen;
32901     +  filename tempopen;
32903     +  %let intvars = ;
32904     +  %global num_intvars;
32905     +  %let num_intvars = 0;
32906     +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
32908     +  /* retrieve the name of frequency variable if it exists */
32909     +  %let em_bin_freq = ;
32910     +  %let choice = ROLE="FREQ";
32911     +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
32912     +  %if &fdsid %then %do;
32913     +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
32914     +    %let fobs = %sysfunc(fetch(&fdsid));
32915     +    %do %while(&fobs=0);
32916     +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
32917     +       %let fobs = %sysfunc(fetch(&fdsid));
32918     +    %end;
32919     +  %end;
32920     +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
32922     +  /* process all inputs */
32923     +  %if &num_intvars > 0 %then %do;
32925     +    /* Computing quantile binning of interval inputs */
32926     +    %let numbin = %eval(&NUMBINS - 1);
32927     +    %let optstr=;
32928     +    %do i=1 %to &numbin;
32929     +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
32930     +    %end;
32932     +    data tempInt / view = tempInt;
32933     +      set &input(keep= %intvars
32934     +      %if &em_bin_freq ne %then %do;
32935     +        &em_bin_freq
32936     +      %end;
32937     +      );
32938     +    run;
32940     +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
32941     +       var %intvars;
32942     +       %if &em_bin_freq ne %then %do;
32943     +          freq &em_bin_freq / notrunc;
32944     +       %end;
32945     +    run;
32947     +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
32948     +    run;
32950     +    /* generate unique BIN_xxx names for all inputs processed */
32951     +    proc dmdb data=tempvars outtable=tempmapping nameserver;
32952     +     names NAME;
32953     +     prefix BIN_ ;
32954     +    run;
32956     +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
32957     +    proc sort data=work.pctdata; by _NAME_; run;
32958     +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
32959     +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar variable) ; by codeVar; run;
32960     +    %end;
32962     +    data tempbins;
32963     +      length display_var $32;
32964     +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
32965     +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
32966     +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
32967     +      %end;
32968     +      ;
32969     +      by _NAME_;
32970     +      if _a;
32971     +      if missing(display_var) then display_var = _NAME_;
32972     +    run;
32974     +    /* generate BINMAPPINGS dataset and binningCode file*/
32975     +    data _null_;
32976     +      FILE &binningCode;
32977     +      set tempbins end=eof;
32978     +      length string $200;
32979     +      by _NAME_;
32981     +      if _n_=1 then do;
32982     +        put "&EM_CODEBAR;";
32983     +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
32984     +        put "* &note;";
32985     +        put "&EM_CODEBAR;";
32987     +        call execute(" data &BINMAPPINGS; ");
32988     +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
32989     +      end;
32991     +      %do i=1 %to %eval(&numbins-1);
32992     +       %if &i eq 1 %then %do;
32993     +         %let colname = COL&i;
32994     +         %let binvalnum = 1;
32995     +         LB = .;
32996     +         UB = round(&colname, &precision);
32997     +         bin=&binvalnum;
32999     +         call execute("name='"||strip(_NAME_)||"'; ");
33000     +         call execute("bin_name='"||strip(binVar)||"'; ");
33001     +         call execute("bin='"||strip(bin)||"';");
33002     +         call execute("LB=.;");
33003     +         call execute("UB="||UB||";");
33004     +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
33005     +         call execute("output;");
33007     +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
33009     +         put string;
33010     +         string = "else do;";
33011     +         put string;
33013     +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
33014     +         put string;
33017     +       %end;
33018     +       %else %do;
33019     +         %let colname = COL&i;
33020     +         %let lbnum = %sysevalf(&i-1);
33021     +         %let lbcol = COL&lbnum;
33022     +         UB = round(&colname, &precision);
33023     +         LB = round(&lbcol, &precision);
33024     +         if UB ne LB then do;
33025     +           bin=bin+1;
33027     +           call execute("name='"||strip(_NAME_)||"'; ");
33028     +           call execute("bin_name='"||strip(binVar)||"'; ");
33029     +           call execute("bin='"||strip(bin)||"';");
33030     +           call execute("LB="||LB||";");
33031     +           call execute("UB="||UB||";");
33032     +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
33033     +           call execute("output;");
33035     +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
33036     +           put string;
33038     +         end;
33039     +       %end;
33040     +      %end;
33041     +      %let binvalnum = %sysevalf(&binvalnum + 1);
33042     +      bin=bin+1;
33043     +      LB = round(&colname, &precision);
33044     +      UB = .;
33046     +      call execute("name='"||strip(_NAME_)||"'; ");
33047     +      call execute("bin_name = '"||strip(binVar)||"'; ");
33048     +      call execute("bin='"||strip(bin)||"';");
33049     +      call execute("UB=.;");
33050     +      call execute("LB="||LB||";");
33051     +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
33052     +      call execute("output;");
33054     +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
33055     +      put string;
33056     +      string="end;";
33057     +      put string;
33059     +      if eof then do;
33060     +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
33061     +        call execute("  if LB=UB then delete;");
33062     +        call execute("run;");
33063     +      end;
33065     +    run;
33067     +    /* drop original inputs */
33068     +    %if &dropOriginal=Y %then %do;
33069     +      data _null_;
33070     +        set work.tempvars end=eof;
33071     +        FILE &binningCode MOD;
33072     +        length string $200;
33074     +        if _n_=1 then do;
33075     +          put "drop";
33076     +        end;
33077     +        string = " "||strip(name);
33078     +        put string;
33080     +        if eof then do;
33081     +          put ";";
33082     +        end;
33083     +      run;
33084     +    %end;
33086     +    proc datasets library=work nolist;
33087     +      delete pctdata tempmapping tempbins tempInt;
33088     +    run;
33089     +    quit;
33090     +  %end;
33092     +  proc datasets library=work nolist;
33093     +    delete tempvars;
33094     +  run;
33095     +  quit;
33097     +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 8 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 8 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
33101     +
33102     +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=);
33103     +
33104     +   filename macFile catalog 'work.emutil.macro.source';
33105     +   %let _METAOBS = 0;
33106     +
33107     +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
33108     +                   or (&metadata eq ) %then %do;
33109     +       %put * No metadata data set defined;
33110     +       %goto doend;
33111     +   %end;
33112     +
33113     +   data _null_;
33114     +      length _STRING_ $80;
33115     +      retain _STRING_;
33116     +      set &metadata end=eof;
33117     +      file macFile;
33118     +      %if %nrbquote(&where) ne %then %do;
33119     +          %let whereClause = where (%nrbquote(&where));
33120     +          %unquote(&whereClause);
33121     +      %end;
33122     +      if _N_=1 then do;
33123     +         string = "%"!!"macro &name;";
33124     +         put string;
33125     +      end;
33126     +      if (length(_STRING_) + length(trim(&key))+ 1 < 80) then do;
33127     +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
33128     +         if eof then do;
33129     +            put _STRING_;
33130     +            string = "%"!!"mend &name;";
33131     +            put string;
33132     +            %if (&nummacro ne ) %then %do;
33133     +                string = strip(put(_N_, best.));
33134     +                put "%" "global &nummacro;";
33135     +                put "%" "let &nummacro = " string ";";
33136     +                call symput('_METAOBS', string);
33137     +            %end;
33138     +         end;
33139     +      end;
33140     +      else do;
33141     +         put _STRING_;
33142     +         _string_ = TRIM(&key);
33143     +         if eof then do;
33144     +            put _STRING_;
33145     +            string = "%"!!"mend &name;";
33146     +            put string;
33147     +        end;
33148     +      end;
33149     +      if eof then do;
33150     +         string = strip(put(_N_, best.));
33151     +         call symput('_METAOBS', string);
33152     +         %if (&nummacro ne ) %then %do;
33153     +             put "%" "global &nummacro;";
33154     +             put "%" "let &nummacro = " string ";";
33155     +         %end;
33156     +      end;
33157     +   run;
33158     +
33159     +   %doend:
33160     +   %if ^&_METAOBS %then %do;
33161     +       data _null_;
33162     +          file macFile;
33163     +          put "%" "macro &name;";
33164     +          put "%" "mend &name;";
33165     +          %if (&nummacro ne ) %then %do;
33166     +              put "%" "global &nummacro;";
33167     +              put "%" "let &nummacro = 0;";
33168     +          %end;
33169     +      run;
33170     +   %end;
33171     +   %inc macFile;
33172     +   filename macFile;
33173     +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov 12, 2015 01:26:29 PM,
      Last Modified=Thu, Nov 12, 2015 01:26:29 PM,
      Filename=C:\Users\sakerb01\AppData\Local\Temp\SAS Temporary Files\_TD2040_COB-IT-M10_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 6 records were written to the file MACFILE.
      The minimum record length was 9.
      The maximum record length was 68.
NOTE: There were 8 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
33174     +%macro intvars;
33175     +Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor
33176     +TotalArea
33177     +%mend intvars;
33178     +%global num_intvars;
33179     +%let num_intvars = 8 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor TotalArea );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor TotalArea
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.17 seconds
      cpu time            0.17 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: There were 193 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 9 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.18 seconds
      cpu time            0.18 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 8 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 8 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 8 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 8 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: There were 8 observations read from the data set WORK.PCTDATA.
NOTE: There were 8 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 8 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generating Bins for interval variables;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS1.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139   292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44    357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      Filename=C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=12Nov2015:13:26:29,
      Create Time=10Nov2015:18:31:41

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 43;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age < 43';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 43;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 46;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='43 <= Age < 46';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 46;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 50;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='46 <= Age < 50';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 50;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age >= 50';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Basement < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Basement >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1 <= Baths < 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths >= 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='ConstructionType';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_ConstructionType';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='ConstructionType < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='ConstructionType';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_ConstructionType';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='ConstructionType >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea < 1154';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1357;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1154 <= TotalArea < 1357';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1357;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1566;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1357 <= TotalArea < 1566';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1566;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea >= 1566';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 48 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 8 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS1.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='Age';
4         + bin_name='BIN_Age';
5         + bin='1';
6         + LB=.;
7         + UB=          43;
8         + EM_BIN_LABEL='Age < 43';
9         + output;
10        + name='Age';
11        + bin_name='BIN_Age';
12        + bin='2';
13        + LB=          43;
14        + UB=          46;
15        + EM_BIN_LABEL='43 <= Age < 46';
16        + output;
17        + name='Age';
18        + bin_name='BIN_Age';
19        + bin='3';
20        + LB=          46;
21        + UB=          50;
22        + EM_BIN_LABEL='46 <= Age < 50';
23        + output;
24        + name='Age';
25        + bin_name = 'BIN_Age';
26        + bin='4';
27        + UB=.;
28        + LB=          50;
29        + EM_BIN_LABEL='Age >= 50';
30        + output;
31        + name='Basement';
32        + bin_name='BIN_Basement';
33        + bin='1';
34        + LB=.;
35        + UB=           0;
36        + EM_BIN_LABEL='Basement < 0';
37        + output;
38        + name='Basement';
39        + bin_name = 'BIN_Basement';
40        + bin='2';
41        + UB=.;
42        + LB=           0;
43        + EM_BIN_LABEL='Basement >= 0';
44        + output;
45        + name='Baths';
46        + bin_name='BIN_Baths';
47        + bin='1';
48        + LB=.;
49        + UB=           1;
50        + EM_BIN_LABEL='Baths < 1';
51        + output;
52        + name='Baths';
53        + bin_name='BIN_Baths';
54        + bin='2';
55        + LB=           1;
56        + UB=           2;
57        + EM_BIN_LABEL='1 <= Baths < 2';
58        + output;
59        + name='Baths';
60        + bin_name = 'BIN_Baths';
61        + bin='3';
62        + UB=.;
63        + LB=           2;
64        + EM_BIN_LABEL='Baths >= 2';
65        + output;
66        + name='ConstructionType';
67        + bin_name='BIN_ConstructionType';
68        + bin='1';
69        + LB=.;
70        + UB=           1;
71        + EM_BIN_LABEL='ConstructionType < 1';
72        + output;
73        + name='ConstructionType';
74        + bin_name = 'BIN_ConstructionType';
75        + bin='2';
76        + UB=.;
77        + LB=           1;
78        + EM_BIN_LABEL='ConstructionType >= 1';
79        + output;
80        + name='FirePlace';
81        + bin_name='BIN_FirePlace';
82        + bin='1';
83        + LB=.;
84        + UB=           1;
85        + EM_BIN_LABEL='FirePlace < 1';
86        + output;
87        + name='FirePlace';
88        + bin_name = 'BIN_FirePlace';
89        + bin='2';
90        + UB=.;
91        + LB=           1;
92        + EM_BIN_LABEL='FirePlace >= 1';
93        + output;
94        + name='GarageSize';
95        + bin_name='BIN_GarageSize';
96        + bin='1';
97        + LB=.;
98        + UB=           1;
99        + EM_BIN_LABEL='GarageSize < 1';
100       + output;
101       + name='GarageSize';
102       + bin_name = 'BIN_GarageSize';
103       + bin='2';
104       + UB=.;
105       + LB=           1;
106       + EM_BIN_LABEL='GarageSize >= 1';
107       + output;
108       + name='SecondFloor';
109       + bin_name='BIN_SecondFloor';
110       + bin='1';
111       + LB=.;
112       + UB=           0;
113       + EM_BIN_LABEL='SecondFloor < 0';
114       + output;
115       + name='SecondFloor';
116       + bin_name = 'BIN_SecondFloor';
117       + bin='2';
118       + UB=.;
119       + LB=           0;
120       + EM_BIN_LABEL='SecondFloor >= 0';
121       + output;
122       + name='TotalArea';
123       + bin_name='BIN_TotalArea';
124       + bin='1';
125       + LB=.;
126       + UB=        1154;
127       + EM_BIN_LABEL='TotalArea < 1154';
128       + output;
129       + name='TotalArea';
130       + bin_name='BIN_TotalArea';
131       + bin='2';
132       + LB=        1154;
133       + UB=        1357;
134       + EM_BIN_LABEL='1154 <= TotalArea < 1357';
135       + output;
136       + name='TotalArea';
137       + bin_name='BIN_TotalArea';
138       + bin='3';
139       + LB=        1357;
140       + UB=        1566;
141       + EM_BIN_LABEL='1357 <= TotalArea < 1566';
142       + output;
143       + name='TotalArea';
144       + bin_name = 'BIN_TotalArea';
145       + bin='4';
146       + UB=.;
147       + LB=        1566;
148       + EM_BIN_LABEL='TotalArea >= 1566';
149       + output;
150       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
151       +   if LB=UB then delete;
152       + run;

NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 21 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      Filename=C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=1528,
      Last Modified=12Nov2015:13:26:29,
      Create Time=10Nov2015:18:31:41

NOTE: 10 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 16.
NOTE: There were 8 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 21 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      76:96   
NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 21 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedmapping nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: 13 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 8 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 8 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 8 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas.
33180     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
33181     +* Generating Bins for interval variables;
MPRINT(EM_QUANTILE_BINNING):   * Generating Bins for interval variables;
33182     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
33183     +if Age eq . then BIN_Age= .;
MPRINT(EM_QUANTILE_BINNING):   if Age eq . then BIN_Age= .;
33184     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33185     +if Age < 43 then BIN_Age=1;
MPRINT(EM_QUANTILE_BINNING):   if Age < 43 then BIN_Age=1;
33186     +else if Age < 46 then BIN_Age=2;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 46 then BIN_Age=2;
33187     +else if Age < 50 then BIN_Age=3;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 50 then BIN_Age=3;
33188     +else if Age >= 50 then BIN_Age=4;
MPRINT(EM_QUANTILE_BINNING):   else if Age >= 50 then BIN_Age=4;
33189     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33190     +if Basement eq . then BIN_Basement= .;
MPRINT(EM_QUANTILE_BINNING):   if Basement eq . then BIN_Basement= .;
33191     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33192     +if Basement < 0 then BIN_Basement=1;
MPRINT(EM_QUANTILE_BINNING):   if Basement < 0 then BIN_Basement=1;
33193     +else if Basement >= 0 then BIN_Basement=2;
MPRINT(EM_QUANTILE_BINNING):   else if Basement >= 0 then BIN_Basement=2;
33194     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33195     +if Baths eq . then BIN_Baths= .;
MPRINT(EM_QUANTILE_BINNING):   if Baths eq . then BIN_Baths= .;
33196     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33197     +if Baths < 1 then BIN_Baths=1;
MPRINT(EM_QUANTILE_BINNING):   if Baths < 1 then BIN_Baths=1;
33198     +else if Baths < 2 then BIN_Baths=2;
MPRINT(EM_QUANTILE_BINNING):   else if Baths < 2 then BIN_Baths=2;
33199     +else if Baths >= 2 then BIN_Baths=3;
MPRINT(EM_QUANTILE_BINNING):   else if Baths >= 2 then BIN_Baths=3;
33200     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33201     +if ConstructionType eq . then BIN_ConstructionType= .;
MPRINT(EM_QUANTILE_BINNING):   if ConstructionType eq . then BIN_ConstructionType= .;
33202     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33203     +if ConstructionType < 1 then BIN_ConstructionType=1;
MPRINT(EM_QUANTILE_BINNING):   if ConstructionType < 1 then BIN_ConstructionType=1;
33204     +else if ConstructionType >= 1 then BIN_ConstructionType=2;
MPRINT(EM_QUANTILE_BINNING):   else if ConstructionType >= 1 then BIN_ConstructionType=2;
33205     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33206     +if FirePlace eq . then BIN_FirePlace= .;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace eq . then BIN_FirePlace= .;
33207     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33208     +if FirePlace < 1 then BIN_FirePlace=1;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace < 1 then BIN_FirePlace=1;
33209     +else if FirePlace >= 1 then BIN_FirePlace=2;
MPRINT(EM_QUANTILE_BINNING):   else if FirePlace >= 1 then BIN_FirePlace=2;
33210     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33211     +if GarageSize eq . then BIN_GarageSize= .;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize eq . then BIN_GarageSize= .;
33212     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33213     +if GarageSize < 1 then BIN_GarageSize=1;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize < 1 then BIN_GarageSize=1;
33214     +else if GarageSize >= 1 then BIN_GarageSize=2;
MPRINT(EM_QUANTILE_BINNING):   else if GarageSize >= 1 then BIN_GarageSize=2;
33215     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33216     +if SecondFloor eq . then BIN_SecondFloor= .;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor eq . then BIN_SecondFloor= .;
33217     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33218     +if SecondFloor < 0 then BIN_SecondFloor=1;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor < 0 then BIN_SecondFloor=1;
33219     +else if SecondFloor >= 0 then BIN_SecondFloor=2;
MPRINT(EM_QUANTILE_BINNING):   else if SecondFloor >= 0 then BIN_SecondFloor=2;
33220     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33221     +if TotalArea eq . then BIN_TotalArea= .;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea eq . then BIN_TotalArea= .;
33222     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
33223     +if TotalArea < 1154 then BIN_TotalArea=1;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea < 1154 then BIN_TotalArea=1;
33224     +else if TotalArea < 1357 then BIN_TotalArea=2;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1357 then BIN_TotalArea=2;
33225     +else if TotalArea < 1566 then BIN_TotalArea=3;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1566 then BIN_TotalArea=3;
33226     +else if TotalArea >= 1566 then BIN_TotalArea=4;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea >= 1566 then BIN_TotalArea=4;
33227     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
33228     +drop
33229     +Age
33230     +Basement
33231     +Baths
33232     +ConstructionType
33233     +FirePlace
33234     +GarageSize
33235     +SecondFloor
33236     +TotalArea
33237     +;
MPRINT(EM_QUANTILE_BINNING):   drop Age Basement Baths ConstructionType FirePlace GarageSize SecondFloor TotalArea ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set EMWS1.BINNING_BINDATA has 193 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      199:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: There were 8 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 29 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 29 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 29 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 29 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 29 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 1 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov 12, 2015 01:26:29 PM,
      Last Modified=Thu, Nov 12, 2015 01:26:29 PM,
      Filename=C:\Users\sakerb01\AppData\Local\Temp\SAS Temporary Files\_TD2040_COB-IT-M10_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 0 records were written to the file MACFILE.
NOTE: There were 0 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   put "%" "macro classvars;";
MPRINT(EM_VARMACRO):   put "%" "mend classvars;";
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = 0;";
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Nov 12, 2015 01:26:29 PM,
      Last Modified=Thu, Nov 12, 2015 01:26:30 PM,
      Filename=C:\Users\sakerb01\AppData\Local\Temp\SAS Temporary Files\_TD2040_COB-IT-M10_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M1,Host Created=X64_7PRO

NOTE: 4 records were written to the file MACFILE.
      The minimum record length was 16.
      The maximum record length was 23.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
33238     +%macro classvars;
33239     +%mend classvars;
33240     +%global num_classvars;
33241     +%let num_classvars = 0;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 29 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 29 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 29 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 29 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 2 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS1.Trans_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class BasementType CentralAir ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _WARN_ is uninitialized.
NOTE: Records processed = 193   Memory used = 511K.
NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.25 seconds
      cpu time            0.25 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 5 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.28 seconds
      cpu time            0.28 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 5 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 5 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 2 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 5 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="BasementType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="CentralAir";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="BINARY";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 2 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "BasementType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "2" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "CentralAir" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "BINARY";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "1" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 5 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 7 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 29 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 29 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 7 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS1.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 29 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 7 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 36 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS1.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: 26 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "AGE" then _proc_var_ = "BIN_Age";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BASEMENT" then _proc_var_ = "BIN_Basement";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BATHS" then _proc_var_ = "BIN_Baths";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CONSTRUCTIONTYPE" then _proc_var_ = "BIN_ConstructionType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "FIREPLACE" then _proc_var_ = "BIN_FirePlace";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "GARAGESIZE" then _proc_var_ = "BIN_GarageSize";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "SECONDFLOOR" then _proc_var_ = "BIN_SecondFloor";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "TOTALAREA" then _proc_var_ = "BIN_TotalArea";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BASEMENTTYPE" then _proc_var_ = "BasementType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CENTRALAIR" then _proc_var_ = "CentralAir";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table BIN_SalePrice / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 13 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS1.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 193 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
33242     +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
33243     +
33244     +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
33245     +      length INDEXVAR $32; retain _index 0;
33246     +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
33247     +      if strip(LEVEL) eq 'INTERVAL' then delete;
33248     +      else do;
33249     +         _index+1;
33250     +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
33251     +      end;
33252     +   run;
33253     +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
33254     +%macro em_NormalizeClassVars(indata=,
33255     +                          cmeta=,
33256     +                          encodedTarget=N,
33257     +                          target=,
33258     +                          targetEvent=,
33259     +                          targetNonEvent=,
33260     +                          outdata=);
33261     + %let dsid = %sysfunc(open(&cmeta));
33262     + %let vn_name =%sysfunc(varnum(&dsid, NAME));
33263     + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
33264     + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
33265     + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
33266     +
33267     + data &outdata/view=&outdata;
33268     +      length _normedvar32 $32.;
33269     +      set &indata( rename = (
33270     +      %let k = 1;
33271     +      %do %while(^%sysfunc(fetch(&dsid)));
33272     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
33273     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
33274     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
33275     +          &_name = &_indexvar
33276     +          %let k = %eval(&k+1);
33277     +      %end;
33278     +      ));
33279     +      drop  _normedvar32;
33280     +
33281     +      %let rc=%sysfunc(rewind(&dsid));
33282     +      %let k = 1;
33283     +      %do %while(^%sysfunc(fetch(&dsid)));
33284     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
33285     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
33286     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
33287     +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
33288     +          %if &_format ne %then %do;
33289     +              _normedvar32 = put(&_indexvar, &_format);
33290     +          %end;
33291     +          %else %do;
33292     +              %if &_type = N %then %do;
33293     +                  _normedvar32 = put(&_indexvar, Best12.);
33294     +              %end;
33295     +              %else %do;
33296     +                  _normedvar32 = put(&_indexvar, $32.);
33297     +              %end;
33298     +          %end;
33299     +          %DMNORMIP(_normedvar32);
33300     +          &_name = _normedvar32;
33301     +          drop &_indexvar;
33302     +          %let k = %eval(&k+1);
33303     +      %end;
33304     +      %let dsid = %sysfunc(close(&dsid));
33305     +
33306     +      %if &encodedTarget = Y %then %do;
33307     +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
33308     +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
33309     +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
33310     +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0;
33311     +      %end;
33312     + run;
33313     +
33314     +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 10 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      78:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      81:105   
NOTE: There were 13 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 10 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 11 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 10 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 10 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BIN_Age = _INDEXVAR1 BIN_Basement = _INDEXVAR2 BasementType = _INDEXVAR3 BIN_Baths = _INDEXVAR4 CentralAir = _INDEXVAR5 BIN_ConstructionType = _INDEXVAR6 BIN_FirePlace = _INDEXVAR7 
BIN_GarageSize = _INDEXVAR8 BIN_SecondFloor = _INDEXVAR9 BIN_TotalArea = _INDEXVAR10 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Age = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Basement = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BasementType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Baths = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   CentralAir = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_ConstructionType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_FirePlace = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_GarageSize = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_SecondFloor = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_TotalArea = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 10 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * BIN_SalePrice/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * BIN_SalePrice/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_Age
5         + BIN_Basement
6         + BIN_Baths
7         + BIN_ConstructionType
8         + BIN_FirePlace
9         + BIN_GarageSize
10        + BIN_SecondFloor
11        + BIN_TotalArea
12        + BasementType
13        + CentralAir
14        + ) * BIN_SalePrice/ missing;
15        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           0.48 seconds
      cpu time            0.21 seconds
      
NOTE: There were 193 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 96 observations and 21 variables.
NOTE: There were 193 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.53 seconds
      cpu time            0.26 seconds
      

16        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
17        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Age' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Age ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Basement' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Basement ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Baths' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Baths ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_ConstructionType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_ConstructionType ;
The SAS System

MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_FirePlace' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_FirePlace ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_GarageSize' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_GarageSize ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_SecondFloor' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_SecondFloor ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_TotalArea' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_TotalArea ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BasementType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BasementType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'CentralAir' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=CentralAir ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_Age' then do;
6         +   _split_value_=BIN_Age                         ;
7         + end;
8         + if strip(RowVariable) = 'BIN_Basement' then do;
9         +   _split_value_=BIN_Basement                    ;
10        + end;
11        + if strip(RowVariable) = 'BIN_Baths' then do;
12        +   _split_value_=BIN_Baths                       ;
13        + end;
14        + if strip(RowVariable) = 'BIN_ConstructionType' then do;
15        +   _split_value_=BIN_ConstructionType            ;
16        + end;
17        + if strip(RowVariable) = 'BIN_FirePlace' then do;
18        +   _split_value_=BIN_FirePlace                   ;
19        + end;
20        + if strip(RowVariable) = 'BIN_GarageSize' then do;
21        +   _split_value_=BIN_GarageSize                  ;
22        + end;
23        + if strip(RowVariable) = 'BIN_SecondFloor' then do;
24        +   _split_value_=BIN_SecondFloor                 ;
25        + end;
26        + if strip(RowVariable) = 'BIN_TotalArea' then do;
27        +   _split_value_=BIN_TotalArea                   ;
28        + end;
29        + if strip(RowVariable) = 'BasementType' then do;
30        +   _split_value_=BasementType                    ;
31        + end;
32        + if strip(RowVariable) = 'CentralAir' then do;
33        +   _split_value_=CentralAir                      ;
34        + end;
35        + keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
36        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 44 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 44 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 44 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 44 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 44 observations read from the data set WORK.CROSSTABS.
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 44 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 44 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 44 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 13 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = BIN_SalePrice;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. This might cause unexpected results.
NOTE: There were 44 observations read from the data set WORK.CROSSTABS.
NOTE: There were 13 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 47 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 47 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 47 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 389:122   1 at 398:134   1 at 401:129   
NOTE: There were 47 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 23 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 23 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 23 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 23 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 23 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 36 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 21 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS1.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 23 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: There were 36 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 21 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Age" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Basement" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "BasementType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Baths" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "CentralAir" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="BINARY";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "ConstructionType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "FirePlace" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "GarageSize" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "SecondFloor" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "TotalArea" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table BIN_SalePrice / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS1.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 46 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 46 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 46 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 98;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 95;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 98 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 95 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 46 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 36 observations and 4 variables.
NOTE: The data set WORK.TEMPCOARSE has 36 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 36 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 10 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS1.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Event Rate" nonEventRate = "Non-Event Rate" _group_ = "Group" role = "Role" _gini_ = "Gini Coefficient" eventcount = "Event Count" noneventcount = "Non-Event Count" groupresprate = 
"Group Event Rate" groupnonresprate = "Group Non-Event Rate" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 10 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 36 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 10 observations read from the data set WORK.GINI.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.14 seconds
      cpu time            0.12 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y "C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      Filename=C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=12Nov2015:13:26:33,
      Create Time=10Nov2015:18:31:41

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_SPLITVALS out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 21 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 26 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 21 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 26 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 26 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      Filename=C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=108,
      Last Modified=12Nov2015:13:26:33,
      Create Time=10Nov2015:18:31:41

NOTE: 120 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 58.
NOTE: There were 26 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file C:\Users\sakerb01\Desktop\SAS EM 12.3 Tutorials _ Projects\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas.
33315     + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
33316     + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Group Values";
33317     +
33318     +if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
33319     +_LABEL_='Age< 43';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Age< 43';
33320     +UB=43;
MPRINT(EM_GENERATE_LABELVALUES):   UB=43;
33321     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33322     +else
33323     +if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
33324     +_LABEL_='43<= Age< 46';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='43<= Age< 46';
33325     +UB=46;
MPRINT(EM_GENERATE_LABELVALUES):   UB=46;
33326     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33327     +else
33328     +if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
33329     +_LABEL_='46<= Age< 50';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='46<= Age< 50';
33330     +UB=50;
MPRINT(EM_GENERATE_LABELVALUES):   UB=50;
33331     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33332     +else
33333     +if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
33334     +_LABEL_='50<= Age';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='50<= Age';
33335     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33336     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33337     +
33338     +if DISPLAY_VAR='Basement' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Basement' and _GROUP_ = 2 then do;
33339     +_LABEL_='Basement< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Basement< 0';
33340     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
33341     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33342     +else
33343     +if DISPLAY_VAR='Basement' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Basement' and _GROUP_ = 3 then do;
33344     +_LABEL_='0<= Basement';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= Basement';
33345     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33346     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33347     +
33348     +if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
33349     +_LABEL_='Baths< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Baths< 1';
33350     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
33351     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33352     +else
33353     +if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
33354     +_LABEL_='1<= Baths< 2';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= Baths< 2';
33355     +UB=2;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2;
33356     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33357     +else
33358     +if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
33359     +_LABEL_='2<= Baths';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2<= Baths';
33360     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33361     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33362     +
33363     +if DISPLAY_VAR='ConstructionType' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='ConstructionType' and _GROUP_ = 2 then do;
33364     +_LABEL_='ConstructionType< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='ConstructionType< 1';
33365     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
33366     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33367     +else
33368     +if DISPLAY_VAR='ConstructionType' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='ConstructionType' and _GROUP_ = 3 then do;
33369     +_LABEL_='1<= ConstructionType';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= ConstructionType';
33370     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33371     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33372     +
33373     +if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
33374     +_LABEL_='FirePlace< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='FirePlace< 1';
33375     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
33376     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33377     +else
33378     +if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
33379     +_LABEL_='1<= FirePlace';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= FirePlace';
33380     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33381     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33382     +
33383     +if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
33384     +_LABEL_='GarageSize< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='GarageSize< 1';
33385     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
33386     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33387     +else
33388     +if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
33389     +_LABEL_='1<= GarageSize';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= GarageSize';
33390     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33391     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33392     +
33393     +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
33394     +_LABEL_='SecondFloor< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='SecondFloor< 0';
33395     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
33396     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33397     +else
33398     +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
33399     +_LABEL_='0<= SecondFloor';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= SecondFloor';
33400     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33401     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33402     +
33403     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
33404     +_LABEL_='TotalArea< 1154';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='TotalArea< 1154';
33405     +UB=1154;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1154;
33406     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33407     +else
33408     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
33409     +_LABEL_='1154<= TotalArea< 1357';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1154<= TotalArea< 1357';
33410     +UB=1357;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1357;
33411     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33412     +else
33413     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
33414     +_LABEL_='1357<= TotalArea< 1566';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1357<= TotalArea< 1566';
33415     +UB=1566;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1566;
33416     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33417     +else
33418     +if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
33419     +_LABEL_='1566<= TotalArea';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1566<= TotalArea';
33420     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
33421     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
33422     +
33423     +if DISPLAY_VAR='BasementType' and _GROUP_ = 2 then
33424     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='BasementType' and _GROUP_ = 2 then _LABEL_='2';
33425     +else
33426     +if DISPLAY_VAR='BasementType' and _GROUP_ = 3 then
33427     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='BasementType' and _GROUP_ = 3 then _LABEL_='1';
33428     +else
33429     +if DISPLAY_VAR='BasementType' and _GROUP_ = 4 then
33430     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='BasementType' and _GROUP_ = 4 then _LABEL_='0';
33431     +
33432     +if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then
33433     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then _LABEL_='1';
33434     +else
33435     +if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then
33436     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then _LABEL_='0';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Age" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Basement" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "BasementType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Baths" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "CentralAir" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "ConstructionType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "FirePlace" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "GarageSize" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "SecondFloor" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "TotalArea" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE FITSTATISTICS CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "BIN_SalePrice";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.63447910250838;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
33437      *------------------------------------------------------------*;
33438      * End TRAIN: BINNING;
33439      *------------------------------------------------------------*;
33440      

33441      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
33442      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
33443      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
33444      ;
MPRINT(EM_DIAGRAM):   ;
33445      ;
MPRINT(EM_DIAGRAM):   ;
33446      ;
MPRINT(EM_DIAGRAM):   ;
33447      ;
MPRINT(EM_DIAGRAM):   ;
33448      quit;
MPRINT(EM_DIAGRAM):   quit;
33449      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
33450      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
33451      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
33452      /*; *"; *'; */
33453      ;
MPRINT(EM_DIAGRAM):   ;
33454      run;
MPRINT(EM_DIAGRAM):   run;
33455      quit;
MPRINT(EM_DIAGRAM):   quit;
33456      /* Reset EM Options */
33457      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
33458      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
33459      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
33460      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
33461      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
33462      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
